<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>阵型生成器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 15px;
            color: #fff;
            font-size: 14px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
        }

        .main-content {
            display: grid;
            grid-template-columns: minmax(420px, 470px) minmax(0, 1fr);
            gap: 15px;
            min-width: 0;
            align-items: start;
            height: calc(100vh - 30px);
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
        }

        .config-panel {
            height: 100%;
            overflow-y: auto;
            padding-right: 4px;
        }

        .workspace-panel {
            height: 100%;
            min-height: 0;
        }

        .config-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .config-title {
            font-size: 1em;
            margin-bottom: 10px;
            color: #f093fb;
            font-weight: bold;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .config-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .config-item label {
            white-space: nowrap;
            font-size: 0.9em;
        }

        input[type="number"], input[type="text"], select {
            width: 80px;
            padding: 8px;
            font-size: 0.9em;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            text-align: center;
        }

        select {
            width: 100%;
            cursor: pointer;
        }

        input[type="text"] {
            width: 100%;
            text-align: left;
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.65);
        }

        option {
            background: #1a1a2e;
            color: #fff;
        }

        .slider-wrap {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .short-slider {
            max-width: 250px;
        }

        .short-slider input[type="range"] {
            max-width: 170px;
        }

        input[type="range"] {
            flex: 1;
            accent-color: #38ef7d;
        }

        .slider-value {
            min-width: 38px;
            text-align: right;
            font-size: 0.85em;
            color: #38ef7d;
            font-weight: 600;
        }

        button {
            padding: 10px 20px;
            font-size: 0.9em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 15px rgba(245, 87, 108, 0.4);
        }

        .btn-export {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-export:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 15px rgba(56, 239, 125, 0.4);
        }

        #btnSimulatePlay.simulating {
            --simulate-progress: 0;
            background:
                linear-gradient(
                    90deg,
                    rgba(56, 239, 125, 0.95) 0%,
                    rgba(56, 239, 125, 0.95) calc(var(--simulate-progress) * 1%),
                    rgba(255, 255, 255, 0.22) calc(var(--simulate-progress) * 1%),
                    rgba(255, 255, 255, 0.22) 100%
                );
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.28);
        }

        #btnSimulatePlay.simulating:hover {
            transform: none;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.28);
        }

        #btnSimulatePlay:disabled {
            cursor: wait;
            opacity: 1;
        }

        .global-interaction-blocker {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: none;
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.01);
        }

        body.simulation-locked .global-interaction-blocker {
            display: block;
        }

        .btn-generate {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
        }

        .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 15px rgba(250, 112, 154, 0.4);
        }

        .direction-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .direction-grid.compact {
            grid-template-columns: repeat(9, minmax(0, 1fr));
            gap: 6px;
        }

        .direction-item {
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 6px;
            border: 2px solid transparent;
            transition: all 0.3s;
            cursor: pointer;
            text-align: center;
        }

        .direction-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .direction-item.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.2);
        }

        .direction-item input {
            display: none;
        }

        .direction-name {
            font-weight: bold;
            color: #667eea;
            font-size: 0.85em;
        }

        .direction-grid.compact .direction-item {
            padding: 6px 0;
        }

        .direction-grid.compact .direction-name {
            font-size: 0.8em;
            font-weight: 700;
        }

        .probability-grid {
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .probability-grid .config-item {
            display: block;
        }

        .probability-grid .config-item label {
            display: block;
            white-space: normal;
            margin-bottom: 4px;
        }

        .result-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .result-title {
            font-size: 1em;
            margin-bottom: 10px;
            color: #667eea;
            font-weight: bold;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .result-item {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .result-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #38ef7d;
        }

        .result-label {
            font-size: 0.75em;
            opacity: 0.8;
            margin-top: 2px;
        }

        .pool-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .pool-title {
            font-size: 1em;
            margin-bottom: 8px;
            color: #f093fb;
            font-weight: bold;
        }

        .pool-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .pool-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .pool-count {
            background: rgba(255,255,255,0.3);
            padding: 1px 6px;
            border-radius: 8px;
            font-size: 0.8em;
        }

        .error-msg {
            background: rgba(245, 87, 108, 0.3);
            color: #f5576c;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.9em;
        }

        .controls-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .controls-row button {
            flex: 1;
            white-space: nowrap;
        }

        .config-group-actions {
            flex-wrap: nowrap;
        }

        .config-group-actions button {
            min-width: 0;
            padding: 9px 8px;
            font-size: 0.84em;
        }

        .board-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            width: 100%;
            min-width: 0;
            flex: 1;
            overflow: hidden;
            height: 100%;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 8px;
        }

        .board-top-tools {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }

        .board-top-actions {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 8px;
        }

        .board-top-actions button {
            width: 100%;
            min-width: 0;
            padding: 9px 10px;
        }

        .board-wrapper {
            transform-origin: top left;
            transition: transform 0.3s ease;
            min-width: 0;
            max-height: none;
            display: flex;
            justify-content: flex-start;
            width: max-content;
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .board {
            display: grid;
            gap: 1px;
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            position: relative;
        }

        .board.play-mode {
            backdrop-filter: none;
        }

        .play-link-overlay {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
            overflow: visible;
        }

        .play-link-path {
            fill: none;
            stroke: #ffd54f;
            stroke-width: 5;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 4px rgba(255, 213, 79, 0.7));
        }

        .cell {
            width: 150px;
            height: 162px;
            background: rgba(255,255,255,0.15);
            border-radius: 4px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease;
            overflow: hidden;
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .cell.filled {
            background: rgba(102, 126, 234, 0.4);
            padding: 2px;
        }

        .board.play-mode .cell.filled {
            cursor: pointer;
            transition: transform 0.15s ease;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
        }

        .board.play-mode .cell.play-selected {
            transform: translateY(-30px);
            transition: none;
            z-index: 8;
            will-change: transform;
        }

        .board.play-mode .cell.play-clearing {
            transform: translateY(-30px) scale(0);
            transition: transform 0.15s ease;
        }

        .board.play-mode.play-shifting {
            pointer-events: none;
        }

        .board.play-mode.play-no-transition .cell,
        .board.play-mode.play-no-transition .cell.filled {
            transition: none !important;
        }

        .board.play-mode .cell.play-shift-anim {
            animation-duration: 0.15s;
            animation-timing-function: linear;
            animation-fill-mode: both;
            animation-name: play-shift-variable;
        }

        @keyframes play-shift-variable {
            from {
                transform: translate3d(var(--shift-start-x, 0px), var(--shift-start-y, 0px), 0);
            }
            to { transform: translate3d(0, 0, 0); }
        }

        .card-image-stack {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .card-image-stack img {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: top center;
            pointer-events: none;
            user-select: none;
            backface-visibility: hidden;
            will-change: transform, opacity;
        }

        .card-image-base {
            z-index: 1;
            transform: scale(1.3);
            transform-origin: top center;
        }

        .card-image-guide {
            z-index: 2;
            transform: scale(1.05);
            transform-origin: top center;
            object-position: top center;
            opacity: 0;
            transition: opacity 0.12s ease;
        }

        .card-image-face {
            z-index: 3;
            transform: scale(1.2);
            transform-origin: top center;
        }

        .board.play-mode .cell.play-selected .card-image-guide {
            opacity: 1;
        }

        .info {
            text-align: left;
            margin-top: 2px;
            font-size: 0.9em;
            opacity: 0.8;
        }

        .stats-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            margin-top: 10px;
        }

        .board-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 330px;
            gap: 10px;
            width: 100%;
            height: 100%;
            flex: 1;
            align-items: start;
        }

        .board-side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: auto;
            height: 100%;
            overflow: auto;
        }

        .board-layout .result-section,
        .board-layout .stats-section {
            margin-top: 0;
            width: auto;
        }

        .stats-line {
            text-align: left;
            margin-top: 6px;
            font-size: 0.85em;
            line-height: 1.45;
            opacity: 0.9;
            word-break: break-word;
            white-space: pre-wrap;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .stats-item {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 8px 10px;
        }

        .stats-item-title {
            font-size: 0.78em;
            letter-spacing: 0.02em;
            opacity: 0.8;
            color: #b9d7ff;
            margin-bottom: 4px;
        }

        .stats-actions {
            margin-bottom: 8px;
        }

        .stats-actions button {
            width: 100%;
        }

        @media (max-width: 1500px) {
            .main-content {
                grid-template-columns: minmax(360px, 430px) minmax(0, 1fr);
            }

            .board-layout {
                grid-template-columns: minmax(0, 1fr) 300px;
            }
        }

        @media (max-width: 1280px) {
            .main-content {
                grid-template-columns: 1fr;
                height: auto;
            }

            .config-panel {
                height: auto;
                max-height: none;
                overflow: visible;
                padding-right: 0;
            }

            .workspace-panel {
                height: auto;
                min-height: 0;
            }

            .direction-grid {
                grid-template-columns: repeat(5, 1fr);
            }

            .direction-grid.compact {
                grid-template-columns: repeat(9, minmax(0, 1fr));
            }

            .board-layout {
                grid-template-columns: 1fr;
                height: auto;
            }

            .board-side-panel {
                height: auto;
                max-height: none;
                overflow: visible;
            }

            .board-container {
                height: 72vh;
            }
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .main-content {
                height: auto;
            }

            .direction-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .direction-grid.compact {
                grid-template-columns: repeat(5, minmax(0, 1fr));
            }

            .cell {
                width: 80px;
                height: 72px;
            }

            .board {
                gap: 1px;
                padding: 5px;
            }

            .controls-row button {
                min-width: 120px;
            }

            .board-top-actions {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="panel config-panel">
                <div class="config-section">
                    <div class="config-title">棋盘尺寸</div>
                    <div class="config-grid">
                        <div class="config-item">
                            <label>宽度：</label>
                            <div class="slider-wrap short-slider">
                                <input
                                    type="range"
                                    id="width"
                                    min="6"
                                    max="10"
                                    step="1"
                                    value="8"
                                    oninput="document.getElementById('widthValue').textContent=this.value; calculatePool();"
                                >
                                <span class="slider-value" id="widthValue">8</span>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>高度：</label>
                            <div class="slider-wrap short-slider">
                                <input
                                    type="range"
                                    id="height"
                                    min="6"
                                    max="14"
                                    step="1"
                                    value="14"
                                    oninput="document.getElementById('heightValue').textContent=this.value; calculatePool();"
                                >
                                <span class="slider-value" id="heightValue">14</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="config-title">数字配置</div>
                    <div class="config-grid">
                        <div class="config-item">
                            <label>8张同色：</label>
                            <input type="number" id="count8" min="0" max="20" value="0" onchange="calculatePool()">
                        </div>
                        <div class="config-item">
                            <label>6张同色：</label>
                            <input type="number" id="count6" min="0" max="20" value="0" onchange="calculatePool()">
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="config-title">方向规则</div>
                    <div class="direction-grid compact">
                        <div class="direction-item selected" onclick="selectDirection(0)" title="无规则">
                            <input type="radio" name="direction" value="0" checked>
                            <div class="direction-name">0</div>
                        </div>
                        <div class="direction-item" onclick="selectDirection(1)" title="向上">
                            <input type="radio" name="direction" value="1">
                            <div class="direction-name">1</div>
                        </div>
                        <div class="direction-item" onclick="selectDirection(2)" title="向下">
                            <input type="radio" name="direction" value="2">
                            <div class="direction-name">2</div>
                        </div>
                        <div class="direction-item" onclick="selectDirection(3)" title="向左">
                            <input type="radio" name="direction" value="3">
                            <div class="direction-name">3</div>
                        </div>
                        <div class="direction-item" onclick="selectDirection(4)" title="向右">
                            <input type="radio" name="direction" value="4">
                            <div class="direction-name">4</div>
                        </div>
                        <div class="direction-item" onclick="selectDirection(5)" title="上下向内">
                            <input type="radio" name="direction" value="5">
                            <div class="direction-name">5</div>
                        </div>
                        <div class="direction-item" onclick="selectDirection(6)" title="左右向内">
                            <input type="radio" name="direction" value="6">
                            <div class="direction-name">6</div>
                        </div>
                        <div class="direction-item" onclick="selectDirection(7)" title="上下向外">
                            <input type="radio" name="direction" value="7">
                            <div class="direction-name">7</div>
                        </div>
                        <div class="direction-item" onclick="selectDirection(8)" title="左右向外">
                            <input type="radio" name="direction" value="8">
                            <div class="direction-name">8</div>
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="config-title">概率参数 (0-1)</div>
                    <div class="config-grid probability-grid">
                        <div class="config-item">
                            <label>同列/同行同数字概率：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="sameLie"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.1"
                                    oninput="document.getElementById('sameLieValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="sameLieValue">0.10</span>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>同位置相同概率：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="sameNum"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.1"
                                    oninput="document.getElementById('sameNumValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="sameNumValue">0.10</span>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>相邻列同位置相同概率：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="xianglinSame"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.1"
                                    oninput="document.getElementById('xianglinSameValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="xianglinSameValue">0.10</span>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>方向上下重叠控制：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="directionBothCtrl"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.50"
                                    oninput="document.getElementById('directionBothCtrlValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="directionBothCtrlValue">0.50</span>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>同色邻近概率（8格）：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="distanceCtrl"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.1"
                                    oninput="document.getElementById('distanceCtrlValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="distanceCtrlValue">0.10</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="config-title">配置组</div>
                    <div class="config-grid" style="grid-template-columns: 1fr;">
                        <div class="config-item">
                            <label>配置名：</label>
                            <input type="text" id="configGroupName" placeholder="输入配置名后保存">
                        </div>
                        <div class="config-item">
                            <label>已保存：</label>
                            <select id="configGroupSelect" onchange="loadSelectedConfigGroup()">
                                <option value="">请选择配置组</option>
                            </select>
                        </div>
                    </div>
                    <div class="controls-row config-group-actions" style="margin-top: 8px;">
                        <button class="btn-primary" onclick="saveCurrentConfigGroup()">保存配置组</button>
                        <button class="btn-secondary" onclick="deleteSelectedConfigGroup()">删除配置组</button>
                        <button class="btn-export" onclick="triggerImportConfigGroups()">读取配置组</button>
                        <button class="btn-primary" onclick="exportConfigToClipboard()">导出参数</button>
                    </div>
                    <input
                        type="file"
                        id="configGroupFileInput"
                        accept=".json,application/json"
                        onchange="handleConfigGroupFileChange(event)"
                        style="display: none;"
                    >
                </div>

                <div class="config-section">
                    <div class="config-title">批量生成</div>
                    <div class="controls-row" style="margin-top: 8px;">
                        <div class="config-item" style="flex: 1; min-width: 180px;">
                            <label>生成数量：</label>
                            <input type="number" id="batchCount" min="1" max="100" value="10">
                        </div>
                        <button class="btn-export" onclick="batchGenerate()">导出批量</button>
                    </div>
                </div>

                <div class="error-msg" id="errorMsg" style="display: none;"></div>
            </div>

            <div class="panel workspace-panel">
                <div class="board-layout">
                    <div class="board-container">
                        <div class="board-top-tools">
                            <div class="board-top-actions">
                                <button class="btn-generate" onclick="fillBoard()">填入数字</button>
                                <button class="btn-primary" onclick="generateBoard()">刷新棋盘</button>
                                <button class="btn-secondary" onclick="clearBoard()">清空</button>
                                <button class="btn-export" id="btnExportSingle"
                                    onclick="exportToClipboard()">导出当前</button>
                            </div>
                            <div class="info" id="info"></div>
                        </div>
                        <div class="board-wrapper" id="boardWrapper">
                            <div class="board" id="board"></div>
                        </div>
                    </div>

                    <div class="board-side-panel">
                        <div class="result-section">
                            <div class="result-title">配置结果</div>
                            <div class="result-grid">
                                <div class="result-item">
                                    <div class="result-value" id="result8">0</div>
                                    <div class="result-label">8张种类</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="result6">0</div>
                                    <div class="result-label">6张种类</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="result4">0</div>
                                    <div class="result-label">4张种类</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="result2">0</div>
                                    <div class="result-label">2张种类</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="resultTotalTypes">0</div>
                                    <div class="result-label">种类数</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="resultTotalCards">0</div>
                                    <div class="result-label">总卡牌</div>
                                </div>
                            </div>
                        </div>

                        <div class="stats-section">
                            <div class="result-title">每关统计</div>
                            <div class="stats-actions">
                                <button class="btn-primary" id="btnStepGenerate" onclick="stepGenerateOrNext()">分步生成</button>
                                <button class="btn-secondary" id="btnPlayMode" onclick="togglePlayMode()"
                                    style="margin-top: 8px;">试玩模式</button>
                                <button class="btn-export" id="btnSimulatePlay" onclick="simulatePlayGames()"
                                    style="margin-top: 8px;">模拟100局</button>
                            </div>
                            <div class="stats-grid">
                                <div class="stats-item">
                                    <div class="stats-item-title">数字池分布</div>
                                    <div class="stats-line" id="levelStatsTypes">-</div>
                                </div>
                                <div class="stats-item">
                                    <div class="stats-item-title">相邻数字对数</div>
                                    <div class="stats-line" id="levelStatsPairs">-</div>
                                </div>
                                <div class="stats-item">
                                    <div class="stats-item-title">相邻基准线相同数字数量</div>
                                    <div class="stats-line" id="levelStatsAdjacent">-</div>
                                </div>
                                <div class="stats-item">
                                    <div class="stats-item-title">方向上下重叠统计（数字:数量）</div>
                                    <div class="stats-line" id="levelStatsDirectionBoth">-</div>
                                </div>
                                <div class="stats-item">
                                    <div class="stats-item-title">模拟100局胜率</div>
                                    <div class="stats-line" id="levelStatsSimulation">-</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="global-interaction-blocker" id="globalInteractionBlocker" aria-hidden="true"></div>

    <script>
        let currentPool = [];
        let filledCells = [];
        let poolCards = [];
        let imageMapping = [];
        let placedCounts = {};
        let stepGenerationState = null;
        let playModeState = null;
        let isSimulatingPlayGames = false;
        let savedConfigGroups = [];
        const CONFIG_GROUP_STORAGE_KEY = 'levelmake.configGroups.v1';
        const ROW_BASE_DIRECTIONS = [3, 4, 6, 8];
        const COLUMN_BASE_DIRECTIONS = [0, 1, 2, 5, 7];

        function isRowBaseDirection(direction) {
            if (ROW_BASE_DIRECTIONS.includes(direction)) return true;
            if (COLUMN_BASE_DIRECTIONS.includes(direction)) return false;
            return false;
        }

        function getLocalBaseDirectionByCell(direction, rowIndex, colIndex, width, height) {
            switch (direction) {
                case 1: return 1;
                case 2: return 2;
                case 3: return 3;
                case 4: return 4;
                case 5:
                    return rowIndex < height / 2 ? 2 : 1;
                case 6:
                    return colIndex < width / 2 ? 4 : 3;
                case 7:
                    return rowIndex < height / 2 ? 1 : 2;
                case 8:
                    return colIndex < width / 2 ? 3 : 4;
                default:
                    return 0;
            }
        }

        function collectDirectionalSideNumbers(rowIndex, colIndex, width, height, localDirection, sideType) {
            const sideNumbers = new Set();
            if (localDirection === 0) return sideNumbers;

            let stepI = 0;
            let stepJ = 0;
            if (localDirection === 1) {
                stepI = sideType === 'top' ? 1 : -1;
            } else if (localDirection === 2) {
                stepI = sideType === 'top' ? -1 : 1;
            } else if (localDirection === 3) {
                stepJ = sideType === 'top' ? 1 : -1;
            } else if (localDirection === 4) {
                stepJ = sideType === 'top' ? -1 : 1;
            }

            let ni = rowIndex + stepI;
            let nj = colIndex + stepJ;
            while (ni >= 0 && ni < height && nj >= 0 && nj < width) {
                const value = filledCells[ni]?.[nj];
                if (Number.isInteger(value) && value > 0) {
                    sideNumbers.add(value);
                }
                ni += stepI;
                nj += stepJ;
            }
            return sideNumbers;
        }

        function shuffleImages() {
            imageMapping = Array.from({length: 34}, (_, i) => i + 1);
            for (let i = imageMapping.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [imageMapping[i], imageMapping[j]] = [imageMapping[j], imageMapping[i]];
            }
        }

        function getImageForNumber(num) {
            const index = (num - 1) % imageMapping.length;
            return imageMapping[index];
        }

        function selectDirection(index) {
            document.querySelectorAll('.direction-item').forEach((item, i) => {
                item.classList.toggle('selected', i === index);
            });
            const radio = document.querySelector(`input[name="direction"][value="${index}"]`);
            if (radio) radio.checked = true;
        }

        function getProbabilityValue(elementId, defaultValue = 0.1) {
            const element = document.getElementById(elementId);
            if (!element) return defaultValue;
            const parsed = parseFloat(element.value);
            if (!Number.isFinite(parsed)) return defaultValue;
            return Math.max(0, Math.min(1, parsed));
        }

        function getDirectionTitleById(directionId) {
            const directionTitles = {
                0: '无规则',
                1: '向上',
                2: '向下',
                3: '向左',
                4: '向右',
                5: '上下向内',
                6: '左右向内',
                7: '上下向外',
                8: '左右向外'
            };
            return directionTitles[directionId] || '无规则';
        }

        function getCurrentConfigSnapshot() {
            return {
                width: parseInt(document.getElementById('width')?.value, 10) || 8,
                height: parseInt(document.getElementById('height')?.value, 10) || 14,
                count8: parseInt(document.getElementById('count8')?.value, 10) || 0,
                count6: parseInt(document.getElementById('count6')?.value, 10) || 0,
                direction: parseInt(
                    document.querySelector('input[name="direction"]:checked')?.value,
                    10
                ) || 0,
                sameLie: getProbabilityValue('sameLie', 0.1),
                sameNum: getProbabilityValue('sameNum', 0.1),
                xianglinSame: getProbabilityValue('xianglinSame', 0.1),
                directionBothCtrl: getProbabilityValue('directionBothCtrl', 0.5),
                batchCount: parseInt(document.getElementById('batchCount')?.value, 10) || 10,
                distanceCtrl: getProbabilityValue('distanceCtrl', 0.1)
            };
        }

        function setSliderControlValue(sliderId, valueLabelId, rawValue, decimals = 2) {
            const slider = document.getElementById(sliderId);
            if (slider) slider.value = String(rawValue);
            const valueLabel = document.getElementById(valueLabelId);
            if (!valueLabel) return;
            if (decimals <= 0) {
                valueLabel.textContent = String(parseInt(String(rawValue), 10));
                return;
            }
            const numericValue = Number(rawValue);
            if (!Number.isFinite(numericValue)) {
                valueLabel.textContent = '0.00';
                return;
            }
            valueLabel.textContent = numericValue.toFixed(decimals);
        }

        function applyConfigSnapshot(config) {
            if (!config || typeof config !== 'object') return;
            const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

            const width = clamp(
                Number.isFinite(Number(config.width)) ? Number(config.width) : 8,
                6,
                10
            );
            const height = clamp(
                Number.isFinite(Number(config.height)) ? Number(config.height) : 14,
                6,
                14
            );
            const count8 = Math.round(clamp(
                Number.isFinite(Number(config.count8)) ? Number(config.count8) : 0,
                0,
                20
            ));
            const count6 = Math.round(clamp(
                Number.isFinite(Number(config.count6)) ? Number(config.count6) : 0,
                0,
                20
            ));
            const direction = Math.round(clamp(
                Number.isFinite(Number(config.direction)) ? Number(config.direction) : 0,
                0,
                8
            ));
            const sameLie = clamp(
                Number.isFinite(Number(config.sameLie)) ? Number(config.sameLie) : 0.1,
                0,
                1
            );
            const sameNum = clamp(
                Number.isFinite(Number(config.sameNum)) ? Number(config.sameNum) : 0.1,
                0,
                1
            );
            const xianglinSame = Number.isFinite(Number(config.xianglinSame))
                ? Number(config.xianglinSame)
                : 0.1;
            const directionBothCtrl = clamp(
                Number.isFinite(Number(config.directionBothCtrl))
                    ? Number(config.directionBothCtrl)
                    : 0.5,
                0,
                1
            );
            const distanceCtrl = clamp(
                Number.isFinite(Number(config.distanceCtrl)) ? Number(config.distanceCtrl) : 0.1,
                0,
                1
            );
            const batchCount = Math.round(clamp(
                Number.isFinite(Number(config.batchCount)) ? Number(config.batchCount) : 10,
                1,
                100
            ));

            if (playModeState && playModeState.active) {
                exitPlayMode({ restoreBoard: true, silent: true });
            }

            setSliderControlValue('width', 'widthValue', Math.round(width), 0);
            setSliderControlValue('height', 'heightValue', Math.round(height), 0);
            setSliderControlValue('sameLie', 'sameLieValue', sameLie, 2);
            setSliderControlValue('sameNum', 'sameNumValue', sameNum, 2);
            setSliderControlValue('xianglinSame', 'xianglinSameValue', clamp(xianglinSame, 0, 1), 2);
            setSliderControlValue('directionBothCtrl', 'directionBothCtrlValue', directionBothCtrl, 2);
            setSliderControlValue('distanceCtrl', 'distanceCtrlValue', distanceCtrl, 2);

            const count8Input = document.getElementById('count8');
            if (count8Input) count8Input.value = String(count8);
            const count6Input = document.getElementById('count6');
            if (count6Input) count6Input.value = String(count6);
            const batchCountInput = document.getElementById('batchCount');
            if (batchCountInput) batchCountInput.value = String(batchCount);

            selectDirection(direction);
            calculatePool();
            setDefaultInfoText();
        }

        function buildDefaultConfigName(config) {
            const directionTitle = getDirectionTitleById(config.direction);
            return `${config.width}x${config.height}_${directionTitle}`;
        }

        function persistConfigGroups() {
            try {
                localStorage.setItem(CONFIG_GROUP_STORAGE_KEY, JSON.stringify(savedConfigGroups));
            } catch (error) {
                console.error('Failed to persist config groups:', error);
            }
        }

        function renderConfigGroupSelect(selectedName = '') {
            const select = document.getElementById('configGroupSelect');
            if (!select) return;

            const targetName = selectedName || select.value || '';
            select.innerHTML = '<option value="">请选择配置组</option>';

            for (const group of savedConfigGroups) {
                const option = document.createElement('option');
                option.value = group.name;
                option.textContent = group.name;
                select.appendChild(option);
            }

            if (targetName && savedConfigGroups.some(group => group.name === targetName)) {
                select.value = targetName;
            } else {
                select.value = '';
            }
        }

        function loadConfigGroupsFromStorage() {
            try {
                const rawValue = localStorage.getItem(CONFIG_GROUP_STORAGE_KEY);
                if (!rawValue) {
                    savedConfigGroups = [];
                    renderConfigGroupSelect();
                    return;
                }
                const parsed = JSON.parse(rawValue);
                if (!Array.isArray(parsed)) {
                    savedConfigGroups = [];
                    renderConfigGroupSelect();
                    return;
                }
                savedConfigGroups = parsed.filter((item) => {
                    return item && typeof item.name === 'string' && item.config;
                });
                renderConfigGroupSelect();
            } catch (error) {
                console.error('Failed to load config groups:', error);
                savedConfigGroups = [];
                renderConfigGroupSelect();
            }
        }

        function saveCurrentConfigGroup() {
            const nameInput = document.getElementById('configGroupName');
            const currentConfig = getCurrentConfigSnapshot();
            const typedName = (nameInput?.value || '').trim();
            const groupName = typedName || buildDefaultConfigName(currentConfig);

            const existingIndex = savedConfigGroups.findIndex(group => group.name === groupName);
            const configGroup = { name: groupName, config: currentConfig };
            const overwritten = existingIndex >= 0;
            if (overwritten) {
                savedConfigGroups[existingIndex] = configGroup;
            } else {
                savedConfigGroups.push(configGroup);
            }

            persistConfigGroups();
            renderConfigGroupSelect(groupName);
            if (nameInput) nameInput.value = groupName;

            const info = document.getElementById('info');
            if (info) {
                info.textContent = overwritten
                    ? `配置组已覆盖：${groupName}`
                    : `配置组已保存：${groupName}`;
            }
        }

        function loadSelectedConfigGroup() {
            const select = document.getElementById('configGroupSelect');
            const nameInput = document.getElementById('configGroupName');
            const selectedName = select?.value || '';
            if (!selectedName) return;

            const selectedGroup = savedConfigGroups.find(group => group.name === selectedName);
            if (!selectedGroup) return;

            applyConfigSnapshot(selectedGroup.config);
            if (nameInput) nameInput.value = selectedGroup.name;

            const info = document.getElementById('info');
            if (info) info.textContent = `已加载配置组：${selectedGroup.name}`;
        }

        function deleteSelectedConfigGroup() {
            const select = document.getElementById('configGroupSelect');
            const nameInput = document.getElementById('configGroupName');
            const selectedName = select?.value || '';
            if (!selectedName) {
                alert('请先在下拉列表中选择要删除的配置组。');
                return;
            }

            savedConfigGroups = savedConfigGroups.filter(group => group.name !== selectedName);
            persistConfigGroups();
            renderConfigGroupSelect();

            if (nameInput && nameInput.value.trim() === selectedName) {
                nameInput.value = '';
            }

            const info = document.getElementById('info');
            if (info) info.textContent = `已删除配置组：${selectedName}`;
        }

        function triggerImportConfigGroups() {
            const fileInput = document.getElementById('configGroupFileInput');
            if (!fileInput) return;
            fileInput.value = '';
            fileInput.click();
        }

        function buildImportedConfigGroupName(item, index, usedNames) {
            const orderValue = Number(item?.['序号']);
            const rawBaseName = Number.isFinite(orderValue)
                ? `序号${Math.round(orderValue)}`
                : `配置${index + 1}`;
            let name = rawBaseName;
            let suffix = 2;
            while (usedNames.has(name)) {
                name = `${rawBaseName}_${suffix}`;
                suffix++;
            }
            usedNames.add(name);
            return name;
        }

        function mapImportedConfigItem(item) {
            const toNumber = (value, fallback) => {
                const numberValue = Number(value);
                return Number.isFinite(numberValue) ? numberValue : fallback;
            };
            return {
                width: toNumber(item?.['宽度'], 8),
                height: toNumber(item?.['高度'], 14),
                count8: toNumber(item?.['8张同色'], 0),
                count6: toNumber(item?.['6张同色'], 0),
                direction: toNumber(item?.['方向'], 0),
                sameLie: toNumber(item?.['同列/同行同数字概率'], 0.1),
                sameNum: toNumber(item?.['同位置相同概率'], 0.1),
                xianglinSame: toNumber(item?.['相邻列同位置相同概率'], 0.1),
                directionBothCtrl: toNumber(item?.['方向上下重叠控制'], 0.5),
                batchCount: 10,
                distanceCtrl: toNumber(
                    item?.['距离参数'] ?? item?.['同色邻近概率（8格）'] ?? item?.['同色邻近概率'],
                    0.1
                )
            };
        }

        function importConfigGroupsFromJsonContent(jsonText) {
            let parsed;
            try {
                parsed = JSON.parse(jsonText);
            } catch (error) {
                throw new Error('JSON格式错误，无法解析。');
            }
            if (!Array.isArray(parsed)) {
                throw new Error('JSON根节点必须是数组。');
            }

            const usedNames = new Set();
            const importedGroups = [];
            for (let index = 0; index < parsed.length; index++) {
                const item = parsed[index];
                if (!item || typeof item !== 'object') continue;
                const groupName = buildImportedConfigGroupName(item, index, usedNames);
                importedGroups.push({
                    name: groupName,
                    config: mapImportedConfigItem(item)
                });
            }

            if (importedGroups.length === 0) {
                throw new Error('JSON中没有可用的配置数据。');
            }

            savedConfigGroups = importedGroups;
            persistConfigGroups();
            renderConfigGroupSelect();

            const nameInput = document.getElementById('configGroupName');
            if (nameInput) nameInput.value = '';

            const info = document.getElementById('info');
            if (info) info.textContent = `已导入配置组：${importedGroups.length} 条（已覆盖本地配置组）`;
        }

        function handleConfigGroupFileChange(event) {
            const file = event?.target?.files?.[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const content = typeof reader.result === 'string' ? reader.result : '';
                    importConfigGroupsFromJsonContent(content);
                } catch (error) {
                    console.error('Failed to import config groups:', error);
                    alert(error.message || '导入失败，请检查JSON格式。');
                }
            };
            reader.onerror = () => {
                console.error('Failed to read config group file:', reader.error);
                alert('读取文件失败，请重试。');
            };
            reader.readAsText(file, 'utf-8');
        }

        function cloneBoardData(boardData) {
            if (!Array.isArray(boardData)) return [];
            return boardData.map((row) => Array.isArray(row) ? [...row] : []);
        }

        function hasFilledCells(boardData) {
            if (!Array.isArray(boardData)) return false;
            for (const row of boardData) {
                if (!Array.isArray(row)) continue;
                for (const value of row) {
                    if (Number.isInteger(value) && value > 0) return true;
                }
            }
            return false;
        }

        function setDefaultInfoText() {
            const width = parseInt(document.getElementById('width').value) || 0;
            const height = parseInt(document.getElementById('height').value) || 0;
            const info = document.getElementById('info');
            if (!info) return;
            if (width > 0 && height > 0) {
                info.textContent = `棋盘: ${width}×${height} = ${width * height} 格`;
            } else {
                info.textContent = '';
            }
        }

        function updatePlayModeButton() {
            const playButton = document.getElementById('btnPlayMode');
            if (!playButton) return;
            playButton.textContent = (playModeState && playModeState.active) ? '退出试玩' : '试玩模式';
        }

        function clearPlaySelectionVisual() {
            if (!playModeState || !playModeState.selected) return;
            const { row, col } = playModeState.selected;
            const selectedCell = document.getElementById(`cell-${row}-${col}`);
            if (selectedCell) {
                selectedCell.classList.remove('play-selected');
                selectedCell.classList.remove('play-clearing');
            }
            playModeState.selected = null;
        }

        function setPlaySelection(row, col) {
            if (!playModeState) return;
            clearPlaySelectionVisual();
            const selectedCell = document.getElementById(`cell-${row}-${col}`);
            if (selectedCell) selectedCell.classList.add('play-selected');
            playModeState.selected = { row, col };
        }

        function waitForMs(durationMs) {
            return new Promise((resolve) => {
                setTimeout(resolve, durationMs);
            });
        }

        function createTokenBoardFromBoard(boardData) {
            if (!Array.isArray(boardData)) return [];
            let nextToken = 1;
            return boardData.map((row) => {
                if (!Array.isArray(row)) return [];
                return row.map((value) => {
                    if (!Number.isInteger(value) || value <= 0) return null;
                    const token = nextToken;
                    nextToken++;
                    return token;
                });
            });
        }

        function getCellStepDistance() {
            const fallback = { stepX: 151, stepY: 166 };
            const originCell = document.getElementById('cell-0-0');
            if (!originCell) return fallback;

            const rightCell = document.getElementById('cell-0-1');
            const downCell = document.getElementById('cell-1-0');
            const originRect = originCell.getBoundingClientRect();

            const stepX = rightCell
                ? Math.abs(rightCell.getBoundingClientRect().left - originRect.left)
                : fallback.stepX;
            const stepY = downCell
                ? Math.abs(downCell.getBoundingClientRect().top - originRect.top)
                : fallback.stepY;

            return {
                stepX: stepX > 0 ? stepX : fallback.stepX,
                stepY: stepY > 0 ? stepY : fallback.stepY
            };
        }

        function collectShiftedCells(beforeTokenBoard, afterTokenBoard) {
            const movedCells = [];
            if (!Array.isArray(beforeTokenBoard) || !Array.isArray(afterTokenBoard)) {
                return movedCells;
            }

            const sourcePositionsByToken = new Map();
            const beforeRows = beforeTokenBoard.length;
            for (let row = 0; row < beforeRows; row++) {
                const cols = beforeTokenBoard[row]?.length || 0;
                for (let col = 0; col < cols; col++) {
                    const token = beforeTokenBoard[row]?.[col];
                    if (!Number.isInteger(token) || token <= 0) continue;
                    sourcePositionsByToken.set(token, { row, col });
                }
            }

            const afterRows = afterTokenBoard.length;
            for (let row = 0; row < afterRows; row++) {
                const cols = afterTokenBoard[row]?.length || 0;
                for (let col = 0; col < cols; col++) {
                    const token = afterTokenBoard[row]?.[col];
                    if (!Number.isInteger(token) || token <= 0) continue;
                    const source = sourcePositionsByToken.get(token);
                    if (!source) continue;
                    if (source.row === row && source.col === col) continue;
                    movedCells.push({
                        row,
                        col,
                        deltaRow: source.row - row,
                        deltaCol: source.col - col
                    });
                }
            }

            return movedCells;
        }

        async function animateBoardShift(movedCells = []) {
            const SHIFT_ANIMATION_MS = 150;
            const board = document.getElementById('board');
            if (!board) return;
            if (!Array.isArray(movedCells) || movedCells.length === 0) return;

            const { stepX, stepY } = getCellStepDistance();
            board.classList.add('play-shifting');
            const animatedCells = [];
            for (const position of movedCells) {
                const cell = document.getElementById(`cell-${position.row}-${position.col}`);
                if (!cell || !cell.classList.contains('filled')) continue;
                const translateX = (position.deltaCol || 0) * stepX;
                const translateY = (position.deltaRow || 0) * stepY;
                cell.style.setProperty('--shift-start-x', `${translateX}px`);
                cell.style.setProperty('--shift-start-y', `${translateY}px`);
                cell.classList.remove('play-shift-anim');
                void cell.offsetWidth;
                cell.classList.add('play-shift-anim');
                animatedCells.push(cell);
            }

            await waitForMs(SHIFT_ANIMATION_MS);
            for (const cell of animatedCells) {
                cell.classList.remove('play-shift-anim');
                cell.style.removeProperty('--shift-start-x');
                cell.style.removeProperty('--shift-start-y');
            }
            board.classList.remove('play-shifting');
        }

        function syncBoardDisplayByData(boardData) {
            if (!Array.isArray(boardData)) return;
            for (let i = 0; i < boardData.length; i++) {
                for (let j = 0; j < boardData[i].length; j++) {
                    renderCellNumber(i, j, boardData[i][j]);
                }
            }
        }

        function syncBoardDisplayWithoutTransition(boardData) {
            const board = document.getElementById('board');
            if (board) board.classList.add('play-no-transition');
            syncBoardDisplayByData(boardData);
            if (board) {
                void board.offsetWidth;
                board.classList.remove('play-no-transition');
            }
        }

        function getCellPositionByElement(cellElement) {
            if (!cellElement || !cellElement.id) return null;
            const idMatch = cellElement.id.match(/^cell-(\d+)-(\d+)$/);
            if (!idMatch) return null;
            return {
                row: parseInt(idMatch[1], 10),
                col: parseInt(idMatch[2], 10)
            };
        }

        function isPlayBoardCleared(boardData) {
            if (!Array.isArray(boardData)) return true;
            for (const row of boardData) {
                if (!Array.isArray(row)) continue;
                for (const value of row) {
                    if (Number.isInteger(value) && value > 0) return false;
                }
            }
            return true;
        }

        function compressPathPoints(pathPoints) {
            if (!Array.isArray(pathPoints) || pathPoints.length <= 2) return pathPoints || [];
            const compressed = [pathPoints[0]];
            for (let index = 1; index < pathPoints.length - 1; index++) {
                const prev = compressed[compressed.length - 1];
                const current = pathPoints[index];
                const next = pathPoints[index + 1];
                const sameRow = prev.row === current.row && current.row === next.row;
                const sameCol = prev.col === current.col && current.col === next.col;
                if (!sameRow && !sameCol) compressed.push(current);
            }
            compressed.push(pathPoints[pathPoints.length - 1]);
            return compressed;
        }

        function findConnectionPathByLianliankan(boardData, startRow, startCol, targetRow, targetCol) {
            if (!Array.isArray(boardData) || boardData.length === 0) return null;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return null;
            if (startRow === targetRow && startCol === targetCol) return null;

            const extHeight = height + 2;
            const extWidth = width + 2;
            const grid = Array.from({ length: extHeight }, () => Array(extWidth).fill(0));

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const value = boardData[row]?.[col];
                    if (Number.isInteger(value) && value > 0) grid[row + 1][col + 1] = value;
                }
            }

            const startExtRow = startRow + 1;
            const startExtCol = startCol + 1;
            const targetExtRow = targetRow + 1;
            const targetExtCol = targetCol + 1;
            if (grid[startExtRow][startExtCol] === 0 || grid[targetExtRow][targetExtCol] === 0) {
                return null;
            }

            const directions = [
                [-1, 0],
                [1, 0],
                [0, -1],
                [0, 1]
            ];
            const visited = Array.from(
                { length: extHeight },
                () => Array.from({ length: extWidth }, () => Array(4).fill(Infinity))
            );

            grid[startExtRow][startExtCol] = 0;
            const queue = [];
            let queueIndex = 0;
            const startPoint = { row: startExtRow, col: startExtCol };

            for (let dir = 0; dir < 4; dir++) {
                const [dr, dc] = directions[dir];
                let nextRow = startExtRow + dr;
                let nextCol = startExtCol + dc;
                while (
                    nextRow >= 0 &&
                    nextRow < extHeight &&
                    nextCol >= 0 &&
                    nextCol < extWidth
                ) {
                    if (nextRow === targetExtRow && nextCol === targetExtCol) {
                        return compressPathPoints([
                            startPoint,
                            { row: nextRow, col: nextCol }
                        ]);
                    }
                    if (grid[nextRow][nextCol] !== 0) break;
                    if (visited[nextRow][nextCol][dir] > 0) {
                        visited[nextRow][nextCol][dir] = 0;
                        queue.push({
                            row: nextRow,
                            col: nextCol,
                            dir,
                            turns: 0,
                            path: [startPoint, { row: nextRow, col: nextCol }]
                        });
                    }
                    nextRow += dr;
                    nextCol += dc;
                }
            }

            while (queueIndex < queue.length) {
                const current = queue[queueIndex];
                queueIndex++;

                for (let nextDir = 0; nextDir < 4; nextDir++) {
                    const nextTurns = current.turns + (nextDir === current.dir ? 0 : 1);
                    if (nextTurns > 2) continue;

                    const [dr, dc] = directions[nextDir];
                    let nextRow = current.row + dr;
                    let nextCol = current.col + dc;

                    while (
                        nextRow >= 0 &&
                        nextRow < extHeight &&
                        nextCol >= 0 &&
                        nextCol < extWidth
                    ) {
                        if (nextRow === targetExtRow && nextCol === targetExtCol) {
                            const targetPath = [...current.path, { row: nextRow, col: nextCol }];
                            return compressPathPoints(targetPath);
                        }
                        if (grid[nextRow][nextCol] !== 0) break;
                        if (visited[nextRow][nextCol][nextDir] > nextTurns) {
                            visited[nextRow][nextCol][nextDir] = nextTurns;
                            queue.push({
                                row: nextRow,
                                col: nextCol,
                                dir: nextDir,
                                turns: nextTurns,
                                path: [...current.path, { row: nextRow, col: nextCol }]
                            });
                        }
                        nextRow += dr;
                        nextCol += dc;
                    }
                }
            }

            return null;
        }

        function getOrCreatePlayLinkOverlay(boardElement) {
            if (!boardElement) return null;
            let overlay = boardElement.querySelector('.play-link-overlay');
            if (overlay) return overlay;
            overlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            overlay.setAttribute('class', 'play-link-overlay');
            overlay.setAttribute('aria-hidden', 'true');
            boardElement.appendChild(overlay);
            return overlay;
        }

        function convertExtPathToBoardPixels(extPath, width, height) {
            if (!Array.isArray(extPath) || extPath.length === 0) return [];
            const board = document.getElementById('board');
            const firstCell = document.getElementById('cell-0-0');
            if (!board || !firstCell) return [];

            const boardRect = board.getBoundingClientRect();
            const firstRect = firstCell.getBoundingClientRect();
            const originX = firstRect.left - boardRect.left + (firstRect.width / 2);
            const originY = firstRect.top - boardRect.top + (firstRect.height / 2);
            const { stepX, stepY } = getCellStepDistance();
            const safeWidth = Math.max(1, width);
            const safeHeight = Math.max(1, height);
            const LINK_VERTICAL_OFFSET = -5;

            return extPath.map((point) => {
                const gridCol = Math.max(-1, Math.min(safeWidth, point.col - 1));
                const gridRow = Math.max(-1, Math.min(safeHeight, point.row - 1));
                return {
                    x: originX + (gridCol * stepX),
                    y: originY + (gridRow * stepY) + LINK_VERTICAL_OFFSET
                };
            });
        }

        function renderPlayLinkPath(extPath, width, height) {
            const board = document.getElementById('board');
            if (!board || !Array.isArray(extPath) || extPath.length < 2) return;

            const overlay = getOrCreatePlayLinkOverlay(board);
            if (!overlay) return;
            overlay.innerHTML = '';
            const boardRect = board.getBoundingClientRect();
            overlay.setAttribute('viewBox', `0 0 ${boardRect.width} ${boardRect.height}`);

            const pixelPoints = convertExtPathToBoardPixels(extPath, width, height);
            if (pixelPoints.length < 2) return;

            const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            polyline.setAttribute('class', 'play-link-path');
            polyline.setAttribute('points', pixelPoints.map((pt) => `${pt.x},${pt.y}`).join(' '));
            overlay.appendChild(polyline);
        }

        function clearPlayLinkPath() {
            const board = document.getElementById('board');
            if (!board) return;
            const overlay = board.querySelector('.play-link-overlay');
            if (overlay) overlay.innerHTML = '';
        }

        function canConnectByLianliankan(boardData, startRow, startCol, targetRow, targetCol) {
            if (!Array.isArray(boardData) || boardData.length === 0) return false;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return false;
            if (startRow === targetRow && startCol === targetCol) return false;

            const extHeight = height + 2;
            const extWidth = width + 2;
            const grid = Array.from({ length: extHeight }, () => Array(extWidth).fill(0));

            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const value = boardData[i]?.[j];
                    if (Number.isInteger(value) && value > 0) {
                        grid[i + 1][j + 1] = value;
                    }
                }
            }

            const startExtRow = startRow + 1;
            const startExtCol = startCol + 1;
            const targetExtRow = targetRow + 1;
            const targetExtCol = targetCol + 1;

            if (grid[startExtRow][startExtCol] === 0 || grid[targetExtRow][targetExtCol] === 0) {
                return false;
            }

            const directionSteps = [
                [-1, 0],
                [1, 0],
                [0, -1],
                [0, 1]
            ];

            const visited = Array.from(
                { length: extHeight },
                () => Array.from({ length: extWidth }, () => Array(4).fill(Infinity))
            );

            grid[startExtRow][startExtCol] = 0;
            const queue = [];
            let queueIndex = 0;

            for (let dir = 0; dir < 4; dir++) {
                const [dr, dc] = directionSteps[dir];
                let nextRow = startExtRow + dr;
                let nextCol = startExtCol + dc;
                while (
                    nextRow >= 0 &&
                    nextRow < extHeight &&
                    nextCol >= 0 &&
                    nextCol < extWidth
                ) {
                    if (nextRow === targetExtRow && nextCol === targetExtCol) {
                        return true;
                    }
                    if (grid[nextRow][nextCol] !== 0) break;
                    if (visited[nextRow][nextCol][dir] > 0) {
                        visited[nextRow][nextCol][dir] = 0;
                        queue.push({ row: nextRow, col: nextCol, dir, turns: 0 });
                    }
                    nextRow += dr;
                    nextCol += dc;
                }
            }

            while (queueIndex < queue.length) {
                const current = queue[queueIndex];
                queueIndex++;

                for (let nextDir = 0; nextDir < 4; nextDir++) {
                    const nextTurns = current.turns + (nextDir === current.dir ? 0 : 1);
                    if (nextTurns > 2) continue;

                    const [dr, dc] = directionSteps[nextDir];
                    let nextRow = current.row + dr;
                    let nextCol = current.col + dc;

                    while (
                        nextRow >= 0 &&
                        nextRow < extHeight &&
                        nextCol >= 0 &&
                        nextCol < extWidth
                    ) {
                        if (nextRow === targetExtRow && nextCol === targetExtCol) {
                            return true;
                        }
                        if (grid[nextRow][nextCol] !== 0) break;
                        if (visited[nextRow][nextCol][nextDir] > nextTurns) {
                            visited[nextRow][nextCol][nextDir] = nextTurns;
                            queue.push({ row: nextRow, col: nextCol, dir: nextDir, turns: nextTurns });
                        }
                        nextRow += dr;
                        nextCol += dc;
                    }
                }
            }

            return false;
        }

        async function processPlayCellSelection(row, col) {
            if (!playModeState || !playModeState.active || playModeState.isResolving) return;
            const boardData = playModeState.boardData;
            const currentValue = boardData?.[row]?.[col];
            if (!Number.isInteger(currentValue) || currentValue <= 0) return;

            const info = document.getElementById('info');
            const selected = playModeState.selected;
            if (!selected) {
                setPlaySelection(row, col);
                if (info) info.textContent = `试玩模式：已选中 ${currentValue}`;
                return;
            }

            if (selected.row === row && selected.col === col) {
                clearPlaySelectionVisual();
                if (info) info.textContent = '试玩模式：已取消选择';
                return;
            }

            const selectedValue = boardData?.[selected.row]?.[selected.col];
            if (!Number.isInteger(selectedValue) || selectedValue <= 0) {
                setPlaySelection(row, col);
                if (info) info.textContent = `试玩模式：已选中 ${currentValue}`;
                return;
            }

            if (selectedValue !== currentValue) {
                setPlaySelection(row, col);
                if (info) info.textContent = `试玩模式：数字不同，重新选中 ${currentValue}`;
                return;
            }

            const canConnect = canConnectByLianliankan(
                boardData,
                selected.row,
                selected.col,
                row,
                col
            );

            if (!canConnect) {
                setPlaySelection(row, col);
                if (info) info.textContent = '试玩模式：路径不满足连连看规则，请重选';
                return;
            }

            const width = boardData[0]?.length || 0;
            const height = boardData.length;
            const linkPath = findConnectionPathByLianliankan(
                boardData,
                selected.row,
                selected.col,
                row,
                col
            );

            playModeState.isResolving = true;
            const firstCell = document.getElementById(`cell-${selected.row}-${selected.col}`);
            const secondCell = document.getElementById(`cell-${row}-${col}`);
            if (firstCell) firstCell.classList.add('play-selected');
            if (secondCell) secondCell.classList.add('play-selected');

            try {
                if (linkPath && linkPath.length >= 2) {
                    renderPlayLinkPath(linkPath, width, height);
                }
                await waitForMs(150);
                if (!playModeState || !playModeState.active) return;

                clearPlayLinkPath();
                if (firstCell) firstCell.classList.add('play-clearing');
                if (secondCell) secondCell.classList.add('play-clearing');

                await waitForMs(150);
                if (!playModeState || !playModeState.active) return;

                boardData[selected.row][selected.col] = null;
                boardData[row][col] = null;
                const tokenBoard = playModeState.tokenBoard;
                if (Array.isArray(tokenBoard)) {
                    tokenBoard[selected.row][selected.col] = null;
                    tokenBoard[row][col] = null;
                }
                const direction = Number.isInteger(playModeState.direction)
                    ? playModeState.direction
                    : 0;
                const tokenBeforeShift = cloneBoardData(tokenBoard);
                applyDirectionShiftUntilStable(boardData, direction);
                if (Array.isArray(tokenBoard)) {
                    applyDirectionShiftUntilStable(tokenBoard, direction);
                }
                playModeState.selected = null;
                syncBoardDisplayWithoutTransition(boardData);
                const movedCells = collectShiftedCells(tokenBeforeShift, tokenBoard);
                await animateBoardShift(movedCells);
                playModeState.clearedPairs = (playModeState.clearedPairs || 0) + 1;

                if (isPlayBoardCleared(boardData)) {
                    if (info) info.textContent = `试玩模式：已清空棋盘，共消除 ${playModeState.clearedPairs} 对`;
                } else {
                    if (info) info.textContent = `试玩模式：已消除 ${playModeState.clearedPairs} 对`;
                }
            } finally {
                if (playModeState && playModeState.active) {
                    playModeState.isResolving = false;
                }
            }
        }

        function exitPlayMode(options = {}) {
            const { restoreBoard = true, silent = false } = options;
            if (!playModeState || !playModeState.active) return;

            if (restoreBoard && Array.isArray(playModeState.originalBoard)) {
                syncBoardDisplayByData(playModeState.originalBoard);
                filledCells = cloneBoardData(playModeState.originalBoard);
            }

            const board = document.getElementById('board');
            if (board) board.classList.remove('play-mode');
            clearPlayLinkPath();

            playModeState = null;
            updatePlayModeButton();

            if (!silent) {
                setDefaultInfoText();
            }
        }

        function enterPlayMode() {
            if (playModeState && playModeState.active) return;
            if (!hasFilledCells(filledCells)) {
                alert('请先生成关卡，再进入试玩模式。');
                return;
            }

            resetStepGenerationState();
            const sourceBoard = cloneBoardData(filledCells);
            playModeState = {
                active: true,
                originalBoard: sourceBoard,
                boardData: cloneBoardData(sourceBoard),
                tokenBoard: createTokenBoardFromBoard(sourceBoard),
                selected: null,
                isResolving: false,
                clearedPairs: 0,
                direction: parseInt(document.querySelector('input[name="direction"]:checked')?.value || 0)
            };

            const board = document.getElementById('board');
            if (board) board.classList.add('play-mode');

            updatePlayModeButton();
            const info = document.getElementById('info');
            if (info) info.textContent = '试玩模式：点击两张相同且可连通的牌进行消除';
        }

        function togglePlayMode() {
            if (playModeState && playModeState.active) {
                exitPlayMode({ restoreBoard: true, silent: false });
                return;
            }
            enterPlayMode();
        }

        function handleBoardCellClick(event) {
            if (!playModeState || !playModeState.active || playModeState.isResolving) return;
            const cellElement = event.target.closest('.cell');
            if (!cellElement) return;
            const position = getCellPositionByElement(cellElement);
            if (!position) return;
            processPlayCellSelection(position.row, position.col);
        }

        function getRemovablePairsForBoard(boardData) {
            if (!Array.isArray(boardData) || boardData.length === 0) return [];
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return [];

            const positionsByNumber = new Map();
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const value = boardData[i]?.[j];
                    if (!Number.isInteger(value) || value <= 0) continue;
                    if (!positionsByNumber.has(value)) positionsByNumber.set(value, []);
                    positionsByNumber.get(value).push({ row: i, col: j });
                }
            }

            const pairs = [];
            positionsByNumber.forEach((positions) => {
                if (!positions || positions.length < 2) return;
                for (let left = 0; left < positions.length - 1; left++) {
                    for (let right = left + 1; right < positions.length; right++) {
                        const first = positions[left];
                        const second = positions[right];
                        if (!canConnectByLianliankan(
                            boardData,
                            first.row,
                            first.col,
                            second.row,
                            second.col
                        )) {
                            continue;
                        }
                        const isAdjacent = Math.abs(first.row - second.row) +
                            Math.abs(first.col - second.col) === 1;
                        pairs.push({
                            row1: first.row,
                            col1: first.col,
                            row2: second.row,
                            col2: second.col,
                            adjacent: isAdjacent
                        });
                    }
                }
            });
            return pairs;
        }

        function pickRandomPair(pairs) {
            if (!pairs || pairs.length === 0) return null;
            const index = Math.floor(Math.random() * pairs.length);
            return pairs[index];
        }

        function compactValues(values, towardStart) {
            const nonEmpty = values.filter((value) => Number.isInteger(value) && value > 0);
            const emptyCount = values.length - nonEmpty.length;
            const emptyValues = Array.from({ length: emptyCount }, () => null);
            return towardStart ? [...nonEmpty, ...emptyValues] : [...emptyValues, ...nonEmpty];
        }

        function getPartitionIndices(length, isFirstPart) {
            const indices = [];
            for (let index = 0; index < length; index++) {
                const inFirstPart = index < (length / 2);
                if ((isFirstPart && inFirstPart) || (!isFirstPart && !inFirstPart)) {
                    indices.push(index);
                }
            }
            return indices;
        }

        function applySegmentCompaction(boardData, segmentIndices, getValue, setValue, towardStart) {
            if (!segmentIndices || segmentIndices.length === 0) return false;
            const originalValues = segmentIndices.map((index) => getValue(index));
            const compactedValues = compactValues(originalValues, towardStart);
            let changed = false;
            for (let idx = 0; idx < segmentIndices.length; idx++) {
                if (originalValues[idx] !== compactedValues[idx]) {
                    changed = true;
                }
                setValue(segmentIndices[idx], compactedValues[idx]);
            }
            return changed;
        }

        function applyDirectionShiftOnce(boardData, direction) {
            if (!Array.isArray(boardData) || boardData.length === 0) return false;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return false;

            let changed = false;
            const topRows = getPartitionIndices(height, true);
            const bottomRows = getPartitionIndices(height, false);
            const leftCols = getPartitionIndices(width, true);
            const rightCols = getPartitionIndices(width, false);

            const compactColumn = (colIndex, rowIndices, towardTop) => {
                const segmentChanged = applySegmentCompaction(
                    boardData,
                    rowIndices,
                    (rowIndex) => boardData[rowIndex]?.[colIndex] ?? null,
                    (rowIndex, value) => {
                        boardData[rowIndex][colIndex] = value;
                    },
                    towardTop
                );
                if (segmentChanged) changed = true;
            };

            const compactRow = (rowIndex, colIndices, towardLeft) => {
                const segmentChanged = applySegmentCompaction(
                    boardData,
                    colIndices,
                    (colIndex) => boardData[rowIndex]?.[colIndex] ?? null,
                    (colIndex, value) => {
                        boardData[rowIndex][colIndex] = value;
                    },
                    towardLeft
                );
                if (segmentChanged) changed = true;
            };

            switch (direction) {
                case 1:
                    for (let col = 0; col < width; col++) compactColumn(col, topRows.concat(bottomRows), true);
                    break;
                case 2:
                    for (let col = 0; col < width; col++) compactColumn(col, topRows.concat(bottomRows), false);
                    break;
                case 3:
                    for (let row = 0; row < height; row++) compactRow(row, leftCols.concat(rightCols), true);
                    break;
                case 4:
                    for (let row = 0; row < height; row++) compactRow(row, leftCols.concat(rightCols), false);
                    break;
                case 5:
                    for (let col = 0; col < width; col++) {
                        compactColumn(col, topRows, false);
                        compactColumn(col, bottomRows, true);
                    }
                    break;
                case 6:
                    for (let row = 0; row < height; row++) {
                        compactRow(row, leftCols, false);
                        compactRow(row, rightCols, true);
                    }
                    break;
                case 7:
                    for (let col = 0; col < width; col++) {
                        compactColumn(col, topRows, true);
                        compactColumn(col, bottomRows, false);
                    }
                    break;
                case 8:
                    for (let row = 0; row < height; row++) {
                        compactRow(row, leftCols, true);
                        compactRow(row, rightCols, false);
                    }
                    break;
                default:
                    break;
            }

            return changed;
        }

        function applyDirectionShiftUntilStable(boardData, direction) {
            const maxIterations = (boardData.length || 0) * ((boardData[0]?.length || 0) + 1);
            let iteration = 0;
            while (iteration < maxIterations) {
                const changed = applyDirectionShiftOnce(boardData, direction);
                if (!changed) break;
                iteration++;
            }
        }

        function simulateSingleGame(baseBoardData, direction) {
            const boardData = cloneBoardData(baseBoardData);
            if (!hasFilledCells(boardData)) return false;

            const maxSteps = boardData.length * (boardData[0]?.length || 0);
            let stepCount = 0;

            while (!isPlayBoardCleared(boardData) && stepCount <= maxSteps) {
                const allPairs = getRemovablePairsForBoard(boardData);
                if (allPairs.length === 0) return false;

                const adjacentPairs = allPairs.filter(pair => pair.adjacent);
                const selectedPair = pickRandomPair(
                    adjacentPairs.length > 0 ? adjacentPairs : allPairs
                );
                if (!selectedPair) return false;

                boardData[selectedPair.row1][selectedPair.col1] = null;
                boardData[selectedPair.row2][selectedPair.col2] = null;
                applyDirectionShiftUntilStable(boardData, direction);
                stepCount++;
            }

            return isPlayBoardCleared(boardData);
        }

        function updateSimulateButtonProgress(progressPercent, labelText) {
            const button = document.getElementById('btnSimulatePlay');
            if (!button) return;
            const numericProgress = Number.isFinite(Number(progressPercent))
                ? Number(progressPercent)
                : 0;
            const safeProgress = Math.max(0, Math.min(100, numericProgress));
            button.style.setProperty('--simulate-progress', safeProgress.toFixed(2));
            if (labelText) button.textContent = labelText;
        }

        function resetSimulateButtonState() {
            const button = document.getElementById('btnSimulatePlay');
            if (!button) return;
            button.disabled = false;
            button.classList.remove('simulating');
            button.style.removeProperty('--simulate-progress');
            button.textContent = '模拟100局';
        }

        function setSimulationInteractionLock(locked) {
            const body = document.body;
            if (!body) return;
            body.classList.toggle('simulation-locked', Boolean(locked));
        }

        async function simulatePlayGames() {
            const GAME_COUNT = 100;
            if (isSimulatingPlayGames) return;
            const sourceBoard = (playModeState && playModeState.active &&
                Array.isArray(playModeState.originalBoard))
                ? cloneBoardData(playModeState.originalBoard)
                : cloneBoardData(filledCells);
            const direction = (playModeState && playModeState.active)
                ? playModeState.direction
                : parseInt(document.querySelector('input[name="direction"]:checked')?.value || 0);

            if (!hasFilledCells(sourceBoard)) {
                alert('请先生成关卡，再进行模拟试玩。');
                return;
            }

            const simulateButton = document.getElementById('btnSimulatePlay');
            isSimulatingPlayGames = true;
            setSimulationInteractionLock(true);
            if (simulateButton) {
                simulateButton.disabled = true;
                simulateButton.classList.add('simulating');
            }
            updateSimulateButtonProgress(0, '模拟中 0%');

            try {
                let winCount = 0;
                for (let gameIndex = 0; gameIndex < GAME_COUNT; gameIndex++) {
                    if (simulateSingleGame(sourceBoard, direction)) {
                        winCount++;
                    }

                    const progressPercent = ((gameIndex + 1) / GAME_COUNT) * 100;
                    updateSimulateButtonProgress(
                        progressPercent,
                        `模拟中 ${Math.round(progressPercent)}%`
                    );

                    if ((gameIndex + 1) % 2 === 0) {
                        await waitForMs(0);
                    }
                }

                const winRate = (winCount / GAME_COUNT) * 100;
                const resultText = `${winCount}/${GAME_COUNT}（${winRate.toFixed(2)}%）`;
                const statsSimulation = document.getElementById('levelStatsSimulation');
                if (statsSimulation) statsSimulation.textContent = resultText;

                const info = document.getElementById('info');
                if (info) {
                    info.textContent = `模拟试玩完成：胜利 ${winCount} 局 / ${GAME_COUNT} 局，胜率 ${winRate.toFixed(2)}%`;
                }
            } finally {
                isSimulatingPlayGames = false;
                setSimulationInteractionLock(false);
                resetSimulateButtonState();
            }
        }

        function calculatePool() {
            const width = parseInt(document.getElementById('width').value) || 8;
            const height = parseInt(document.getElementById('height').value) || 14;
            const count8 = parseInt(document.getElementById('count8').value) || 0;
            const count6 = parseInt(document.getElementById('count6').value) || 0;

            const totalCells = width * height;
            const cardsFrom8 = count8 * 8;
            const cardsFrom6 = count6 * 6;
            const usedCards = cardsFrom8 + cardsFrom6;

            const errorMsg = document.getElementById('errorMsg');
            const resultSection = document.getElementById('resultSection');

            if (usedCards > totalCells) {
                if (errorMsg) {
                    errorMsg.style.display = 'block';
                    errorMsg.textContent = '错误：超出棋盘容量！';
                }
                if (resultSection) resultSection.style.display = 'none';
                return;
            }

            if (errorMsg) errorMsg.style.display = 'none';
            if (resultSection) resultSection.style.display = 'block';

            const remainingCards = totalCells - usedCards;
            let count4 = Math.floor(remainingCards / 4);
            const remainder = remainingCards % 4;

            let count2 = 0;
            if (remainder >= 2) {
                count2 = 1;
            }

            const totalTypes = count8 + count6 + count4 + count2;
            const totalCards = count8 * 8 + count6 * 6 + count4 * 4 + count2 * 2;

            const result8 = document.getElementById('result8');
            const result6 = document.getElementById('result6');
            const result4 = document.getElementById('result4');
            const result2 = document.getElementById('result2');
            const resultTotalTypes = document.getElementById('resultTotalTypes');
            const resultTotalCards = document.getElementById('resultTotalCards');

            if (result8) result8.textContent = count8;
            if (result6) result6.textContent = count6;
            if (result4) result4.textContent = count4;
            if (result2) result2.textContent = count2;
            if (resultTotalTypes) resultTotalTypes.textContent = totalTypes;
            if (resultTotalCards) resultTotalCards.textContent = totalCards;
        }

        function generateBoard() {
            exitPlayMode({ restoreBoard: false, silent: true });
            resetStepGenerationState();
            const width = parseInt(document.getElementById('width').value) || 8;
            const height = parseInt(document.getElementById('height').value) || 14;

            if (width < 6 || width > 10 || height < 6 || height > 14) {
                alert('尺寸请设置在：宽度 6-10，高度 6-14');
                return;
            }

            const btn = document.getElementById('btnExportSingle');
            if (btn) {
                btn.style.background = '';
            }

            calculatePool();
            calculatePoolForGenerate(width, height);

            const board = document.getElementById('board');
            if (!board) return;
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${width}, 150px)`;
            if (width > 8) board.style.gridTemplateColumns = `repeat(${width}, 120px)`;

            filledCells = [];

            for (let i = 0; i < height; i++) {
                filledCells[i] = [];
                for (let j = 0; j < width; j++) {
                    filledCells[i][j] = null;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${i}-${j}`;
                    board.appendChild(cell);
                }
            }

            setDefaultInfoText();
            resetLevelStats();

            setTimeout(scaleBoard, 100);
        }

        function clearBoard() {
            exitPlayMode({ restoreBoard: false, silent: true });
            resetStepGenerationState();
            if (!filledCells || filledCells.length === 0) return;

            const width = parseInt(document.getElementById('width').value) || 8;
            const height = parseInt(document.getElementById('height').value) || 14;

            const btn = document.getElementById('btnExportSingle');
            if (btn) {
                btn.style.background = '';
            }

            for (let i = 0; i < height; i++) {
                if (!filledCells[i]) continue;
                for (let j = 0; j < width; j++) {
                    filledCells[i][j] = null;
                    const cell = document.getElementById(`cell-${i}-${j}`);
                    if (cell) {
                        cell.className = 'cell';
                        cell.innerHTML = '';
                    }
                }
            }
            poolCards = [];
            resetLevelStats();
            setDefaultInfoText();
        }

        function getCellColor(num) {
            const colors = [
                'rgba(255, 99, 132, 0.7)',
                'rgba(54, 162, 235, 0.7)',
                'rgba(255, 206, 86, 0.7)',
                'rgba(75, 192, 192, 0.7)',
                'rgba(153, 102, 255, 0.7)',
                'rgba(255, 159, 64, 0.7)',
                'rgba(199, 199, 199, 0.7)',
                'rgba(83, 102, 255, 0.7)',
                'rgba(40, 167, 69, 0.7)',
                'rgba(220, 53, 69, 0.7)',
                'rgba(0, 123, 255, 0.7)',
                'rgba(255, 193, 7, 0.7)',
                'rgba(23, 162, 184, 0.7)',
                'rgba(255, 7, 84, 0.7)',
                'rgba(108, 117, 125, 0.7)',
                'rgba(102, 16, 242, 0.7)',
                'rgba(253, 126, 20, 0.7)',
                'rgba(32, 201, 151, 0.7)',
                'rgba(255, 123, 254, 0.7)',
                'rgba(134, 199, 89, 0.7)'
            ];
            const index = (num - 1) % colors.length;
            return colors[index];
        }

        function resetStepGenerationState() {
            stepGenerationState = null;
            const stepButton = document.getElementById('btnStepGenerate');
            if (stepButton) stepButton.textContent = '分步生成';
        }

        function buildStepGroups(fillOrder, direction) {
            const groups = [];
            let currentGroup = [];
            for (const item of fillOrder) {
                if (item.firstInGroup && currentGroup.length > 0) {
                    groups.push(currentGroup);
                    currentGroup = [];
                }
                currentGroup.push(item);
            }
            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }

            if (groups.length <= 1) return groups;

            const isRowDirection = isRowBaseDirection(direction);
            const groupMeta = groups.map((group, originalIndex) => {
                let axisIndex = null;
                for (const item of group) {
                    const axisValue = isRowDirection ? item.groupRow : item.groupCol;
                    if (axisValue !== null && axisValue !== undefined) {
                        axisIndex = axisValue;
                        break;
                    }
                }
                return { group, originalIndex, axisIndex };
            });

            const ordered = [groupMeta[0]];
            const used = new Set([groupMeta[0].originalIndex]);

            while (ordered.length < groupMeta.length) {
                const generatedAxis = ordered
                    .map(item => item.axisIndex)
                    .filter(axis => axis !== null && axis !== undefined);

                let best = null;
                for (const candidate of groupMeta) {
                    if (used.has(candidate.originalIndex)) continue;

                    let minGap = Number.POSITIVE_INFINITY;
                    let isAdjacent = false;
                    if (generatedAxis.length > 0 &&
                        candidate.axisIndex !== null &&
                        candidate.axisIndex !== undefined) {
                        for (const axis of generatedAxis) {
                            const gap = Math.abs(candidate.axisIndex - axis);
                            if (gap < minGap) minGap = gap;
                            if (gap === 1) isAdjacent = true;
                        }
                    }

                    if (!best) {
                        best = { candidate, isAdjacent, minGap };
                        continue;
                    }

                    if (isAdjacent && !best.isAdjacent) {
                        best = { candidate, isAdjacent, minGap };
                        continue;
                    }

                    if (isAdjacent === best.isAdjacent) {
                        if (minGap < best.minGap) {
                            best = { candidate, isAdjacent, minGap };
                            continue;
                        }
                        if (minGap === best.minGap &&
                            candidate.originalIndex < best.candidate.originalIndex) {
                            best = { candidate, isAdjacent, minGap };
                        }
                    }
                }

                if (!best) break;
                ordered.push(best.candidate);
                used.add(best.candidate.originalIndex);
            }

            return ordered.map(item => item.group);
        }

        function renderCellNumber(i, j, num) {
            const cell = document.getElementById(`cell-${i}-${j}`);
            if (!cell) return;
            if (!Number.isInteger(num) || num <= 0) {
                cell.className = 'cell';
                cell.innerHTML = '';
                return;
            }
            cell.className = 'cell filled';
            cell.innerHTML = '';
            const imgNum = getImageForNumber(num);
            cell.appendChild(createCardImageStack(imgNum, num));
        }

        function createCardImageStack(imgNum, num) {
            const BASE_IMAGE_PATH = 'img/base.png';
            const stack = document.createElement('div');
            stack.className = 'card-image-stack';

            const baseImage = document.createElement('img');
            baseImage.className = 'card-image-base';
            baseImage.src = BASE_IMAGE_PATH;
            baseImage.alt = '';
            baseImage.setAttribute('aria-hidden', 'true');

            const guideImage = document.createElement('img');
            guideImage.className = 'card-image-guide';
            guideImage.src = 'img/GuideTips.png';
            guideImage.alt = '';
            guideImage.setAttribute('aria-hidden', 'true');

            const faceImage = document.createElement('img');
            faceImage.className = 'card-image-face';
            faceImage.src = `img/${imgNum}.png`;
            faceImage.alt = num.toString();

            stack.appendChild(baseImage);
            stack.appendChild(guideImage);
            stack.appendChild(faceImage);
            return stack;
        }

        function revealNextStepGroup() {
            if (!stepGenerationState) return;
            const { groups, boardData, direction } = stepGenerationState;
            if (stepGenerationState.currentStepIndex >= groups.length) {
                resetStepGenerationState();
                return;
            }

            const currentGroup = groups[stepGenerationState.currentStepIndex];
            for (const item of currentGroup) {
                const { i, j } = item;
                const num = boardData[i]?.[j] ?? 0;
                if (!filledCells[i]) filledCells[i] = [];
                filledCells[i][j] = num;
                renderCellNumber(i, j, num);
            }

            stepGenerationState.currentStepIndex++;
            updateLevelStats(direction);
            setTimeout(scaleBoard, 100);

            const stepButton = document.getElementById('btnStepGenerate');
            if (!stepButton) return;
            if (stepGenerationState.currentStepIndex >= groups.length) {
                stepButton.textContent = '分步生成';
                stepGenerationState = null;
            } else {
                stepButton.textContent =
                    `下一步 (${stepGenerationState.currentStepIndex}/${groups.length})`;
            }
        }

        function startStepGeneration() {
            exitPlayMode({ restoreBoard: false, silent: true });
            const width = parseInt(document.getElementById('width').value) || 8;
            const height = parseInt(document.getElementById('height').value) || 14;
            if (!width || !height) return;

            const direction = parseInt(document.querySelector('input[name="direction"]:checked')?.value || 0);
            const sameLie = getProbabilityValue('sameLie', 0.1);
            const sameNum = getProbabilityValue('sameNum', 0.1);
            const xianglinSame = getProbabilityValue('xianglinSame', 0.1);
            const directionBothCtrl = getProbabilityValue('directionBothCtrl', 0.5);
            const distanceCtrl = getProbabilityValue('distanceCtrl', 0.1);

            generateBoard();
            shuffleImages();

            const boardData = generateSingleLevel(
                direction,
                sameLie,
                sameNum,
                xianglinSame,
                directionBothCtrl,
                distanceCtrl
            );

            const fillOrder = getFillOrder(width, height, direction);
            const groups = buildStepGroups(fillOrder, direction);

            filledCells = [];
            for (let i = 0; i < height; i++) {
                filledCells[i] = [];
                for (let j = 0; j < width; j++) {
                    filledCells[i][j] = null;
                    renderCellNumber(i, j, null);
                }
            }

            stepGenerationState = {
                boardData,
                groups,
                currentStepIndex: 0,
                direction
            };

            revealNextStepGroup();
        }

        function stepGenerateOrNext() {
            if (!stepGenerationState) {
                startStepGeneration();
                return;
            }
            revealNextStepGroup();
        }

        function fillBoard() {
            exitPlayMode({ restoreBoard: false, silent: true });
            resetStepGenerationState();
            shuffleImages();
            const width = parseInt(document.getElementById('width').value) || 8;
            const height = parseInt(document.getElementById('height').value) || 14;
            if (!width || !height) return;

            const direction = parseInt(document.querySelector('input[name="direction"]:checked')?.value || 0);
            const sameLie = getProbabilityValue('sameLie', 0.1);
            const sameNum = getProbabilityValue('sameNum', 0.1);
            const xianglinSame = getProbabilityValue('xianglinSame', 0.1);
            const directionBothCtrl = getProbabilityValue('directionBothCtrl', 0.5);
            const distanceCtrl = getProbabilityValue('distanceCtrl', 0.1);

            const btn = document.getElementById('btnExportSingle');
            if (btn) {
                btn.style.background = '';
            }

            calculatePool();
            calculatePoolForGenerate(width, height);

            filledCells = [];
            for (let i = 0; i < height; i++) {
                filledCells[i] = [];
                for (let j = 0; j < width; j++) {
                    filledCells[i][j] = null;
                }
            }

            const fillOrder = getFillOrder(width, height, direction);

            placedCounts = {};
            currentPool.forEach(item => {
                placedCounts[item.number] = 0;
            });

            for (let idx = 0; idx < fillOrder.length; idx++) {
                const {i, j, prevI, prevJ, firstInGroup, groupCol, groupRow} = fillOrder[idx];
                let num = null;
                const isRowDirection = isRowBaseDirection(direction);

                const hasPoolNumber = (targetNumber) => {
                    const poolItem = currentPool.find(p => p.number === targetNumber);
                    return !!poolItem && placedCounts[targetNumber] < poolItem.count;
                };

                const getGroupUsedNumbers = () => {
                    const usedInGroup = new Set();
                    if (isRowDirection) {
                        for (let jj = 0; jj < width; jj++) {
                            if (filledCells[i]?.[jj] !== null && filledCells[i]?.[jj] !== undefined) {
                                usedInGroup.add(filledCells[i][jj]);
                            }
                        }
                    } else {
                        for (let ii = 0; ii < height; ii++) {
                            if (filledCells[ii]?.[j] !== null && filledCells[ii]?.[j] !== undefined) {
                                usedInGroup.add(filledCells[ii][j]);
                            }
                        }
                    }
                    return usedInGroup;
                };

                const pickByGroupPreference = (preferUsed, forbiddenNumbers = new Set()) => {
                    const usedInGroup = getGroupUsedNumbers();
                    const candidates = [];
                    const allowedCandidates = [];
                    for (const poolItem of currentPool) {
                        const canUse = placedCounts[poolItem.number] < poolItem.count;
                        if (!canUse) continue;
                        const inGroup = usedInGroup.has(poolItem.number);
                        if ((preferUsed && inGroup) || (!preferUsed && !inGroup)) {
                            candidates.push(poolItem.number);
                            if (!forbiddenNumbers.has(poolItem.number)) {
                                allowedCandidates.push(poolItem.number);
                            }
                        }
                    }
                    if (candidates.length === 0) return null;
                    const source = allowedCandidates.length > 0 ? allowedCandidates : candidates;
                    const picked = chooseCandidateByControl(source);
                    if (picked === null) return null;
                    return picked;
                };

                const getAdjacentSamePositionCandidateNumbers = () => {
                    const adjacentCandidates = [];
                    if (isRowDirection) {
                        const upNum = i > 0 ? filledCells[i - 1]?.[j] : null;
                        const downNum = i < height - 1 ? filledCells[i + 1]?.[j] : null;
                        if (upNum !== null && upNum !== undefined) {
                            adjacentCandidates.push(upNum);
                        }
                        if (downNum !== null && downNum !== undefined) {
                            adjacentCandidates.push(downNum);
                        }
                    } else {
                        const leftNum = j > 0 ? filledCells[i]?.[j - 1] : null;
                        const rightNum = j < width - 1 ? filledCells[i]?.[j + 1] : null;
                        if (leftNum !== null && leftNum !== undefined) {
                            adjacentCandidates.push(leftNum);
                        }
                        if (rightNum !== null && rightNum !== undefined) {
                            adjacentCandidates.push(rightNum);
                        }
                    }
                    return adjacentCandidates;
                };

                const getAdjacentLineCandidateSet = () => {
                    const adjacentSet = new Set();
                    if (isRowDirection) {
                        const adjacentRows = [];
                        if (i > 0) adjacentRows.push(i - 1);
                        if (i < height - 1) adjacentRows.push(i + 1);
                        for (const rowIndex of adjacentRows) {
                            for (let colIndex = 0; colIndex < width; colIndex++) {
                                const value = filledCells[rowIndex]?.[colIndex];
                                if (value !== null && value !== undefined) {
                                    adjacentSet.add(value);
                                }
                            }
                        }
                    } else {
                        const adjacentCols = [];
                        if (j > 0) adjacentCols.push(j - 1);
                        if (j < width - 1) adjacentCols.push(j + 1);
                        for (const colIndex of adjacentCols) {
                            for (let rowIndex = 0; rowIndex < height; rowIndex++) {
                                const value = filledCells[rowIndex]?.[colIndex];
                                if (value !== null && value !== undefined) {
                                    adjacentSet.add(value);
                                }
                            }
                        }
                    }
                    return adjacentSet;
                };

                const getAroundNeighborCandidateSet = () => {
                    const aroundSet = new Set();
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            if (di === 0 && dj === 0) continue;
                            const ni = i + di;
                            const nj = j + dj;
                            if (ni < 0 || ni >= height || nj < 0 || nj >= width) continue;
                            const value = filledCells[ni]?.[nj];
                            if (value !== null && value !== undefined) {
                                aroundSet.add(value);
                            }
                        }
                    }
                    return aroundSet;
                };

                const getDirectionBothCandidateSet = () => {
                    const localDirection = getLocalBaseDirectionByCell(direction, i, j, width, height);
                    const upperSet = collectDirectionalSideNumbers(
                        i,
                        j,
                        width,
                        height,
                        localDirection,
                        'top'
                    );
                    const lowerSet = collectDirectionalSideNumbers(
                        i,
                        j,
                        width,
                        height,
                        localDirection,
                        'bottom'
                    );
                    const bothSet = new Set();
                    upperSet.forEach((value) => {
                        if (lowerSet.has(value)) bothSet.add(value);
                    });
                    return bothSet;
                };

                const chooseCandidateByControl = (candidateNumbers) => {
                    if (!candidateNumbers || candidateNumbers.length === 0) return null;
                    const directionBothSet = getDirectionBothCandidateSet();

                    let bestScore = -Infinity;
                    let bestCandidates = [];
                    for (const candidate of candidateNumbers) {
                        const inDirectionBoth = directionBothSet.has(candidate);
                        const directionScore = inDirectionBoth ? directionBothCtrl : (1 - directionBothCtrl);
                        const score = directionScore;
                        if (score > bestScore) {
                            bestScore = score;
                            bestCandidates = [candidate];
                        } else if (score === bestScore) {
                            bestCandidates.push(candidate);
                        }
                    }
                    if (bestCandidates.length === 0) return null;
                    return bestCandidates[Math.floor(Math.random() * bestCandidates.length)];
                };

                const pickByCandidateNumbers = (candidateNumbers, forbiddenNumbers = new Set()) => {
                    if (!candidateNumbers || candidateNumbers.length === 0) return null;
                    const uniqueCandidates = [];
                    const seen = new Set();
                    for (const candidate of candidateNumbers) {
                        if (seen.has(candidate)) continue;
                        seen.add(candidate);
                        if (!hasPoolNumber(candidate)) continue;
                        uniqueCandidates.push(candidate);
                    }
                    if (uniqueCandidates.length === 0) return null;
                    const allowedCandidates = uniqueCandidates.filter(
                        candidate => !forbiddenNumbers.has(candidate)
                    );
                    if (allowedCandidates.length === 0) return null;
                    const source = allowedCandidates;
                    const picked = chooseCandidateByControl(source);
                    if (picked === null) return null;
                    return picked;
                };

                const pickAnyCard = (forbiddenNumbers = new Set()) => {
                    const candidates = [];
                    const allowedCandidates = [];
                    for (const poolItem of currentPool) {
                        const canUse = placedCounts[poolItem.number] < poolItem.count;
                        if (!canUse) continue;
                        candidates.push(poolItem.number);
                        if (!forbiddenNumbers.has(poolItem.number)) {
                            allowedCandidates.push(poolItem.number);
                        }
                    }
                    if (candidates.length === 0) return null;
                    const source = allowedCandidates.length > 0 ? allowedCandidates : candidates;
                    const picked = chooseCandidateByControl(source);
                    if (picked === null) return null;
                    return picked;
                };

                const adjacentSamePositionNumbers = getAdjacentSamePositionCandidateNumbers();
                const adjacentLineNumbers = Array.from(getAdjacentLineCandidateSet());
                const aroundNeighborNumbers = Array.from(getAroundNeighborCandidateSet());
                const forbiddenNumbers = new Set();
                const aroundNeighborNumberSet = new Set(aroundNeighborNumbers);

                const tryAdjacentLineSet = Math.random() < sameNum;
                if (!tryAdjacentLineSet) {
                    adjacentLineNumbers.forEach(value => forbiddenNumbers.add(value));
                }

                const trySamePosition = Math.random() < xianglinSame;
                if (trySamePosition) {
                    num = pickByCandidateNumbers(adjacentSamePositionNumbers, forbiddenNumbers);
                } else {
                    adjacentSamePositionNumbers.forEach(value => forbiddenNumbers.add(value));
                }

                if (num === null) {
                    if (tryAdjacentLineSet) {
                        num = pickByCandidateNumbers(adjacentLineNumbers, forbiddenNumbers);
                    }
                }

                if (num === null) {
                    const preferUsed = Math.random() < sameLie;
                    num = pickByGroupPreference(preferUsed, forbiddenNumbers);
                    if (num === null) {
                        num = pickByGroupPreference(!preferUsed, forbiddenNumbers);
                    }
                }

                if (num === null) {
                    num = pickAnyCard(forbiddenNumbers);
                }

                if (num === null) {
                    num = getNextCard();
                }

                if (num !== null) {
                    if (aroundNeighborNumberSet.has(num) && Math.random() >= distanceCtrl) {
                        const replaceForbiddenNumbers = new Set(forbiddenNumbers);
                        aroundNeighborNumberSet.forEach(value => replaceForbiddenNumbers.add(value));
                        const preferUsedForReplace = Math.random() < sameLie;
                        let replacement = pickByGroupPreference(
                            preferUsedForReplace,
                            replaceForbiddenNumbers
                        );
                        if (replacement === null) {
                            replacement = pickByGroupPreference(
                                !preferUsedForReplace,
                                replaceForbiddenNumbers
                            );
                        }
                        if (replacement === null && tryAdjacentLineSet) {
                            replacement = pickByCandidateNumbers(
                                adjacentLineNumbers,
                                replaceForbiddenNumbers
                            );
                        }
                        if (replacement === null) {
                            replacement = pickAnyCard(replaceForbiddenNumbers);
                        }
                        if (replacement !== null) {
                            num = replacement;
                        }
                    }

                    const reservedCard = getSpecificCard(num);
                    if (reservedCard === null) {
                        num = getNextCard();
                    }
                }

                if (num !== null) {
                    placedCounts[num] = (placedCounts[num] || 0) + 1;
                    filledCells[i][j] = num;
                    const cell = document.getElementById(`cell-${i}-${j}`);
                    if (cell) {
                        cell.className = 'cell filled';
                        cell.innerHTML = '';
                        const imgNum = getImageForNumber(num);
                        cell.appendChild(createCardImageStack(imgNum, num));
                    }
                }
            }
            updateLevelStats(direction);
            setTimeout(scaleBoard, 100);
        }

        function resetLevelStats() {
            const statsTypes = document.getElementById('levelStatsTypes');
            const statsPairs = document.getElementById('levelStatsPairs');
            const statsAdjacent = document.getElementById('levelStatsAdjacent');
            const statsDirectionBoth = document.getElementById('levelStatsDirectionBoth');
            const statsSimulation = document.getElementById('levelStatsSimulation');
            if (statsTypes) statsTypes.textContent = '-';
            if (statsPairs) statsPairs.textContent = '-';
            if (statsAdjacent) statsAdjacent.textContent = '-';
            if (statsDirectionBoth) statsDirectionBoth.textContent = '-';
            if (statsSimulation) statsSimulation.textContent = '-';
        }

        function updateLevelStats(direction) {
            if (!filledCells || filledCells.length === 0) {
                resetLevelStats();
                return;
            }

            const width = parseInt(document.getElementById('width').value) || 0;
            const height = parseInt(document.getElementById('height').value) || 0;
            if (width <= 0 || height <= 0) {
                resetLevelStats();
                return;
            }

            const numberCountMap = new Map();
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const value = filledCells[i]?.[j];
                    if (!Number.isInteger(value) || value <= 0) continue;
                    numberCountMap.set(value, (numberCountMap.get(value) || 0) + 1);
                }
            }

            const countByCopies = (copies) => {
                let total = 0;
                numberCountMap.forEach((count) => {
                    if (count === copies) total++;
                });
                return total;
            };

            const usedTypeCount = numberCountMap.size;
            const kinds8 = countByCopies(8);
            const kinds6 = countByCopies(6);
            const kinds4 = countByCopies(4);
            const kinds2 = countByCopies(2);

            let adjacentPairCount = 0;
            const visited = Array.from({ length: height }, () => Array(width).fill(false));
            const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const startValue = filledCells[i]?.[j];
                    if (!Number.isInteger(startValue) || startValue <= 0 || visited[i][j]) continue;

                    let componentSize = 0;
                    const stack = [[i, j]];
                    visited[i][j] = true;

                    while (stack.length > 0) {
                        const [ci, cj] = stack.pop();
                        componentSize++;
                        for (const [di, dj] of directions) {
                            const ni = ci + di;
                            const nj = cj + dj;
                            if (ni < 0 || ni >= height || nj < 0 || nj >= width) continue;
                            if (visited[ni][nj]) continue;
                            if (filledCells[ni]?.[nj] !== startValue) continue;
                            visited[ni][nj] = true;
                            stack.push([ni, nj]);
                        }
                    }
                    adjacentPairCount += Math.floor(componentSize / 2);
                }
            }

            const isRowDirection = isRowBaseDirection(direction);
            const lineCount = isRowDirection ? height : width;
            const lineSets = [];
            for (let lineIndex = 0; lineIndex < lineCount; lineIndex++) {
                const numberSet = new Set();
                if (isRowDirection) {
                    for (let j = 0; j < width; j++) {
                        const value = filledCells[lineIndex]?.[j];
                        if (Number.isInteger(value) && value > 0) numberSet.add(value);
                    }
                } else {
                    for (let i = 0; i < height; i++) {
                        const value = filledCells[i]?.[lineIndex];
                        if (Number.isInteger(value) && value > 0) numberSet.add(value);
                    }
                }
                lineSets.push(numberSet);
            }

            const countIntersection = (leftSet, rightSet) => {
                let overlapCount = 0;
                leftSet.forEach((value) => {
                    if (rightSet.has(value)) overlapCount++;
                });
                return overlapCount;
            };

            const adjacentOverlapStats = [];
            for (let lineIndex = 0; lineIndex < lineCount; lineIndex++) {
                let overlapTotal = 0;
                if (lineIndex > 0) {
                    overlapTotal += countIntersection(lineSets[lineIndex], lineSets[lineIndex - 1]);
                }
                if (lineIndex < lineCount - 1) {
                    overlapTotal += countIntersection(lineSets[lineIndex], lineSets[lineIndex + 1]);
                }
                adjacentOverlapStats.push(overlapTotal);
            }
            const adjacentOverlapSum = adjacentOverlapStats.reduce((sum, value) => sum + value, 0);
            const adjacentOverlapAvg = lineCount > 0 ? adjacentOverlapSum / lineCount : 0;

            const lineLabel = isRowDirection ? '行' : '列';
            const formatRows = (entries, chunkSize = 4) => {
                if (!entries || entries.length === 0) return '-';
                const lines = [];
                for (let i = 0; i < entries.length; i += chunkSize) {
                    lines.push(entries.slice(i, i + chunkSize).join('  |  '));
                }
                return lines.join('\n');
            };

            const getLocalBaseDirection = (rowIndex, colIndex) => {
                switch (direction) {
                    case 1: return 1;
                    case 2: return 2;
                    case 3: return 3;
                    case 4: return 4;
                    case 5:
                        return rowIndex < height / 2 ? 2 : 1;
                    case 6:
                        return colIndex < width / 2 ? 4 : 3;
                    case 7:
                        return rowIndex < height / 2 ? 1 : 2;
                    case 8:
                        return colIndex < width / 2 ? 3 : 4;
                    default:
                        return 0;
                }
            };

            const collectSideNumbers = (rowIndex, colIndex, localDirection, sideType) => {
                const sideNumbers = new Set();
                if (localDirection === 0) return sideNumbers;

                let stepI = 0;
                let stepJ = 0;
                if (localDirection === 1) {
                    stepI = sideType === 'top' ? 1 : -1;
                } else if (localDirection === 2) {
                    stepI = sideType === 'top' ? -1 : 1;
                } else if (localDirection === 3) {
                    stepJ = sideType === 'top' ? 1 : -1;
                } else if (localDirection === 4) {
                    stepJ = sideType === 'top' ? -1 : 1;
                }

                let ni = rowIndex + stepI;
                let nj = colIndex + stepJ;
                while (ni >= 0 && ni < height && nj >= 0 && nj < width) {
                    const value = filledCells[ni]?.[nj];
                    if (Number.isInteger(value) && value > 0) {
                        sideNumbers.add(value);
                    }
                    ni += stepI;
                    nj += stepJ;
                }
                return sideNumbers;
            };

            const mergeSetMap = new Map();
            const lowerSetMap = new Map();
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const current = filledCells[i]?.[j];
                    if (!Number.isInteger(current) || current <= 0) continue;
                    const localDirection = getLocalBaseDirection(i, j);
                    if (localDirection === 0) continue;

                    const upperSet = collectSideNumbers(i, j, localDirection, 'top');
                    const lowerSet = collectSideNumbers(i, j, localDirection, 'bottom');

                    if (!mergeSetMap.has(current)) mergeSetMap.set(current, new Set());
                    if (!lowerSetMap.has(current)) lowerSetMap.set(current, new Set());

                    upperSet.forEach((value) => mergeSetMap.get(current).add(value));
                    lowerSet.forEach((value) => lowerSetMap.get(current).add(value));
                }
            }

            const directionBothStats = [];
            const sortedNumbers = Array.from(numberCountMap.keys()).sort((a, b) => a - b);
            for (const numberValue of sortedNumbers) {
                const upperSet = mergeSetMap.get(numberValue) || new Set();
                const lowerSet = lowerSetMap.get(numberValue) || new Set();
                let bothCount = 0;
                upperSet.forEach((value) => {
                    if (lowerSet.has(value)) bothCount++;
                });
                directionBothStats.push(`${numberValue}:${bothCount}`);
            }
            const directionBothValues = directionBothStats.map((entry) => {
                const parts = entry.split(':');
                return parseInt(parts[1], 10) || 0;
            });
            const directionBothSum = directionBothValues.reduce((sum, value) => sum + value, 0);
            const directionBothAvg = directionBothValues.length > 0
                ? directionBothSum / directionBothValues.length
                : 0;

            const statsTypes = document.getElementById('levelStatsTypes');
            const statsPairs = document.getElementById('levelStatsPairs');
            const statsAdjacent = document.getElementById('levelStatsAdjacent');
            const statsDirectionBoth = document.getElementById('levelStatsDirectionBoth');
            if (statsTypes) {
                statsTypes.textContent =
                    `使用:${usedTypeCount}  |  8张:${kinds8}  |  6张:${kinds6}\n` +
                    `4张:${kinds4}  |  2张:${kinds2}`;
            }
            if (statsPairs) statsPairs.textContent = `${adjacentPairCount}`;
            if (statsAdjacent) {
                statsAdjacent.textContent =
                    `${formatRows(adjacentOverlapStats.map((value, index) => `${lineLabel}${index + 1}:${value}`), 3)}\n` +
                    `合计:${adjacentOverlapSum}  |  平均:${adjacentOverlapAvg.toFixed(2)}`;
            }
            if (statsDirectionBoth) {
                if (direction === 0) {
                    statsDirectionBoth.textContent = '方向0不统计';
                } else {
                    statsDirectionBoth.textContent =
                        `${formatRows(directionBothStats, 4)}\n` +
                        `合计:${directionBothSum}  |  平均:${directionBothAvg.toFixed(2)}`;
                }
            }
        }

        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function getFillOrder(width, height, direction) {
            const order = [];
            const used = new Set();

            const addCell = (i, j, firstInGroup, groupCol, groupRow) => {
                const key = `${i},${j}`;
                if (!used.has(key)) {
                    order.push({i, j, prevI: null, prevJ: null, firstInGroup, groupCol, groupRow});
                    used.add(key);
                }
            };

            const addAdjacent = (i, j, isRow, firstInGroup, groupCol, groupRow) => {
                const neighbors = isRow
                    ? [[i, j-1], [i, j+1]]
                    : [[i-1, j], [i+1, j]];
                for (const [ni, nj] of neighbors) {
                    if (ni >= 0 && ni < height && nj >= 0 && nj < width) {
                        const key = `${ni},${nj}`;
                        if (!used.has(key)) {
                            order.push({i: ni, j: nj, prevI: i, prevJ: j, firstInGroup: false, groupCol, groupRow});
                            used.add(key);
                        }
                    }
                }
            };

            switch (direction) {
                case 0: {
                    const cols = shuffleArray(Array.from({length: width}, (_, i) => i));
                    for (let colIdx = 0; colIdx < cols.length; colIdx++) {
                        const col = cols[colIdx];
                        for (let i = 0; i < height; i++) {
                            const firstInGroup = (i === 0);
                            addCell(i, col, firstInGroup, col, null);
                            if (i < height - 1) {
                                addAdjacent(i, col, false, false, col, null);
                            }
                        }
                    }
                    break;
                }
                case 1: {
                    for (let j = 0; j < width; j++) {
                        for (let i = height - 1; i >= 0; i--) {
                            const firstInGroup = (i === height - 1);
                            addCell(i, j, firstInGroup, j, null);
                            if (i > 0) {
                                addAdjacent(i, j, false, false, j, null);
                            }
                        }
                    }
                    break;
                }
                case 2: {
                    for (let j = 0; j < width; j++) {
                        for (let i = 0; i < height; i++) {
                            const firstInGroup = (i === 0);
                            addCell(i, j, firstInGroup, j, null);
                            if (i < height - 1) {
                                addAdjacent(i, j, false, false, j, null);
                            }
                        }
                    }
                    break;
                }
                case 3: {
                    const rows = shuffleArray(Array.from({length: height}, (_, i) => i));
                    for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                        const row = rows[rowIdx];
                        for (let j = width - 1; j >= 0; j--) {
                            const firstInGroup = (j === width - 1);
                            addCell(row, j, firstInGroup, null, row);
                            if (j > 0) {
                                addAdjacent(row, j, true, false, null, row);
                            }
                        }
                    }
                    break;
                }
                case 4: {
                    const rows = shuffleArray(Array.from({length: height}, (_, i) => i));
                    for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                        const row = rows[rowIdx];
                        for (let j = 0; j < width; j++) {
                            const firstInGroup = (j === 0);
                            addCell(row, j, firstInGroup, null, row);
                            if (j < width - 1) {
                                addAdjacent(row, j, true, false, null, row);
                            }
                        }
                    }
                    break;
                }
                case 5: {
                    const colsIn = [...Array(width).keys()].sort((a, b) => Math.abs(a - width / 2) - Math.abs(b - width / 2)).reverse();
                    for (let colIdx = 0; colIdx < colsIn.length; colIdx++) {
                        const col = colsIn[colIdx];
                        for (let i = 0; i < height; i++) {
                            const firstInGroup = (i === 0);
                            addCell(i, col, firstInGroup, col, null);
                            if (i < height - 1) {
                                addAdjacent(i, col, false, false, col, null);
                            }
                        }
                    }
                    break;
                }
                case 6: {
                    const rowsIn = [...Array(height).keys()].sort((a, b) => Math.abs(a - height / 2) - Math.abs(b - height / 2)).reverse();
                    for (let rowIdx = 0; rowIdx < rowsIn.length; rowIdx++) {
                        const row = rowsIn[rowIdx];
                        for (let j = 0; j < width; j++) {
                            const firstInGroup = (j === 0);
                            addCell(row, j, firstInGroup, null, row);
                            if (j < width - 1) {
                                addAdjacent(row, j, true, false, null, row);
                            }
                        }
                    }
                    break;
                }
                case 7: {
                    const colsOut = [...Array(width).keys()].sort((a, b) => Math.abs(a - width / 2) - Math.abs(b - width / 2));
                    for (let colIdx = 0; colIdx < colsOut.length; colIdx++) {
                        const col = colsOut[colIdx];
                        for (let i = 0; i < height; i++) {
                            const firstInGroup = (i === 0);
                            addCell(i, col, firstInGroup, col, null);
                            if (i < height - 1) {
                                addAdjacent(i, col, false, false, col, null);
                            }
                        }
                    }
                    break;
                }
                case 8: {
                    const rowsOut = [...Array(height).keys()].sort((a, b) => Math.abs(a - height / 2) - Math.abs(b - height / 2));
                    for (let rowIdx = 0; rowIdx < rowsOut.length; rowIdx++) {
                        const row = rowsOut[rowIdx];
                        for (let j = 0; j < width; j++) {
                            const firstInGroup = (j === 0);
                            addCell(row, j, firstInGroup, null, row);
                            if (j < width - 1) {
                                addAdjacent(row, j, true, false, null, row);
                            }
                        }
                    }
                    break;
                }
            }
            return order;
        }

        function getPoolCards() {
            if (poolCards.length > 0) return poolCards;
            if (!currentPool || currentPool.length === 0) return [];
            poolCards = [];
            currentPool.forEach(poolItem => {
                for (let i = 0; i < poolItem.count; i++) poolCards.push(poolItem.number);
            });
            poolCards = shuffleArray(poolCards);
            return poolCards;
        }

        function getNextCard() {
            const cards = getPoolCards();
            return cards && cards.length > 0 ? cards.pop() : null;
        }

        function getSpecificCard(targetNumber) {
            const cards = getPoolCards();
            if (!cards || cards.length === 0) return null;
            const cardIndex = cards.indexOf(targetNumber);
            if (cardIndex === -1) return null;
            cards.splice(cardIndex, 1);
            return targetNumber;
        }

        function exportConfigToClipboard() {
            const width = parseInt(document.getElementById('width')?.value, 10) || 8;
            const height = parseInt(document.getElementById('height')?.value, 10) || 14;
            const count8 = parseInt(document.getElementById('count8')?.value, 10) || 0;
            const count6 = parseInt(document.getElementById('count6')?.value, 10) || 0;
            const direction = parseInt(
                document.querySelector('input[name="direction"]:checked')?.value,
                10
            ) || 0;
            const sameLie = getProbabilityValue('sameLie', 0.1);
            const sameNum = getProbabilityValue('sameNum', 0.1);
            const xianglinSame = getProbabilityValue('xianglinSame', 0.1);
            const directionBothCtrl = getProbabilityValue('directionBothCtrl', 0.5);
            const distanceCtrl = getProbabilityValue('distanceCtrl', 0.1);

            const toCompactNumber = (value) => String(Number(value.toFixed(2)));
            const values = [
                width,
                height,
                count8,
                count6,
                direction,
                toCompactNumber(sameLie),
                toCompactNumber(sameNum),
                toCompactNumber(xianglinSame),
                toCompactNumber(directionBothCtrl),
                toCompactNumber(distanceCtrl)
            ];

            const tsvText = values.join('\t');
            navigator.clipboard.writeText(tsvText).then(() => {
                const info = document.getElementById('info');
                if (info) {
                    info.textContent = '配置数值已复制到剪贴板（TAB分隔）';
                }
            }).catch((error) => {
                console.error('Failed to export config:', error);
                alert('配置导出失败，请手动复制。');
            });
        }

        function exportToClipboard() {
            const width = parseInt(document.getElementById('width').value) || 8;
            const height = parseInt(document.getElementById('height').value) || 14;

            const boardData = getBoardData();
            const boardStr = JSON.stringify(boardData);

            navigator.clipboard.writeText(boardStr).then(() => {
                const btn = document.getElementById('btnExportSingle');
                if (btn) {
                    btn.style.background = 'rgba(150, 150, 150, 0.6)';
                    btn.style.cursor = 'pointer';
                }
            }).catch(() => {
                alert('复制失败，请手动复制');
            });
        }

        function getBoardData() {
            const width = parseInt(document.getElementById('width').value) || 8;
            const height = parseInt(document.getElementById('height').value) || 14;
            const data = [];
            for (let i = 0; i < height; i++) {
                const row = [];
                for (let j = 0; j < width; j++) {
                    row.push(filledCells[i]?.[j] ?? 0);
                }
                data.push(row);
            }
            return data;
        }

        function generateSingleLevel(
            direction,
            sameLie,
            sameNum,
            xianglinSame,
            directionBothCtrl,
            distanceCtrl
        ) {
            const width = parseInt(document.getElementById('width').value) || 8;
            const height = parseInt(document.getElementById('height').value) || 14;

            currentPool = [];
            poolCards = [];
            calculatePoolForGenerate(width, height);

            const fillOrder = getFillOrder(width, height, direction);
            filledCells = [];

            for (let i = 0; i < height; i++) {
                filledCells[i] = [];
                for (let j = 0; j < width; j++) {
                    filledCells[i][j] = null;
                }
            }

            placedCounts = {};
            currentPool.forEach(item => {
                placedCounts[item.number] = 0;
            });

            for (let idx = 0; idx < fillOrder.length; idx++) {
                const {i, j, prevI, prevJ, firstInGroup, groupCol, groupRow} = fillOrder[idx];
                let num = null;
                const isRowDirection = isRowBaseDirection(direction);

                const hasPoolNumber = (targetNumber) => {
                    const poolItem = currentPool.find(p => p.number === targetNumber);
                    return !!poolItem && placedCounts[targetNumber] < poolItem.count;
                };

                const getGroupUsedNumbers = () => {
                    const usedInGroup = new Set();
                    if (isRowDirection) {
                        for (let jj = 0; jj < width; jj++) {
                            if (filledCells[i]?.[jj] !== null && filledCells[i]?.[jj] !== undefined) {
                                usedInGroup.add(filledCells[i][jj]);
                            }
                        }
                    } else {
                        for (let ii = 0; ii < height; ii++) {
                            if (filledCells[ii]?.[j] !== null && filledCells[ii]?.[j] !== undefined) {
                                usedInGroup.add(filledCells[ii][j]);
                            }
                        }
                    }
                    return usedInGroup;
                };

                const pickByGroupPreference = (preferUsed, forbiddenNumbers = new Set()) => {
                    const usedInGroup = getGroupUsedNumbers();
                    const candidates = [];
                    const allowedCandidates = [];
                    for (const poolItem of currentPool) {
                        const canUse = placedCounts[poolItem.number] < poolItem.count;
                        if (!canUse) continue;
                        const inGroup = usedInGroup.has(poolItem.number);
                        if ((preferUsed && inGroup) || (!preferUsed && !inGroup)) {
                            candidates.push(poolItem.number);
                            if (!forbiddenNumbers.has(poolItem.number)) {
                                allowedCandidates.push(poolItem.number);
                            }
                        }
                    }
                    if (candidates.length === 0) return null;
                    const source = allowedCandidates.length > 0 ? allowedCandidates : candidates;
                    const picked = chooseCandidateByControl(source);
                    if (picked === null) return null;
                    return picked;
                };

                const getAdjacentSamePositionCandidateNumbers = () => {
                    const adjacentCandidates = [];
                    if (isRowDirection) {
                        const upNum = i > 0 ? filledCells[i - 1]?.[j] : null;
                        const downNum = i < height - 1 ? filledCells[i + 1]?.[j] : null;
                        if (upNum !== null && upNum !== undefined) {
                            adjacentCandidates.push(upNum);
                        }
                        if (downNum !== null && downNum !== undefined) {
                            adjacentCandidates.push(downNum);
                        }
                    } else {
                        const leftNum = j > 0 ? filledCells[i]?.[j - 1] : null;
                        const rightNum = j < width - 1 ? filledCells[i]?.[j + 1] : null;
                        if (leftNum !== null && leftNum !== undefined) {
                            adjacentCandidates.push(leftNum);
                        }
                        if (rightNum !== null && rightNum !== undefined) {
                            adjacentCandidates.push(rightNum);
                        }
                    }
                    return adjacentCandidates;
                };

                const getAdjacentLineCandidateSet = () => {
                    const adjacentSet = new Set();
                    if (isRowDirection) {
                        const adjacentRows = [];
                        if (i > 0) adjacentRows.push(i - 1);
                        if (i < height - 1) adjacentRows.push(i + 1);
                        for (const rowIndex of adjacentRows) {
                            for (let colIndex = 0; colIndex < width; colIndex++) {
                                const value = filledCells[rowIndex]?.[colIndex];
                                if (value !== null && value !== undefined) {
                                    adjacentSet.add(value);
                                }
                            }
                        }
                    } else {
                        const adjacentCols = [];
                        if (j > 0) adjacentCols.push(j - 1);
                        if (j < width - 1) adjacentCols.push(j + 1);
                        for (const colIndex of adjacentCols) {
                            for (let rowIndex = 0; rowIndex < height; rowIndex++) {
                                const value = filledCells[rowIndex]?.[colIndex];
                                if (value !== null && value !== undefined) {
                                    adjacentSet.add(value);
                                }
                            }
                        }
                    }
                    return adjacentSet;
                };

                const getAroundNeighborCandidateSet = () => {
                    const aroundSet = new Set();
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            if (di === 0 && dj === 0) continue;
                            const ni = i + di;
                            const nj = j + dj;
                            if (ni < 0 || ni >= height || nj < 0 || nj >= width) continue;
                            const value = filledCells[ni]?.[nj];
                            if (value !== null && value !== undefined) {
                                aroundSet.add(value);
                            }
                        }
                    }
                    return aroundSet;
                };

                const getDirectionBothCandidateSet = () => {
                    const localDirection = getLocalBaseDirectionByCell(direction, i, j, width, height);
                    const upperSet = collectDirectionalSideNumbers(
                        i,
                        j,
                        width,
                        height,
                        localDirection,
                        'top'
                    );
                    const lowerSet = collectDirectionalSideNumbers(
                        i,
                        j,
                        width,
                        height,
                        localDirection,
                        'bottom'
                    );
                    const bothSet = new Set();
                    upperSet.forEach((value) => {
                        if (lowerSet.has(value)) bothSet.add(value);
                    });
                    return bothSet;
                };

                const chooseCandidateByControl = (candidateNumbers) => {
                    if (!candidateNumbers || candidateNumbers.length === 0) return null;
                    const directionBothSet = getDirectionBothCandidateSet();

                    let bestScore = -Infinity;
                    let bestCandidates = [];
                    for (const candidate of candidateNumbers) {
                        const inDirectionBoth = directionBothSet.has(candidate);
                        const directionScore = inDirectionBoth ? directionBothCtrl : (1 - directionBothCtrl);
                        const score = directionScore;
                        if (score > bestScore) {
                            bestScore = score;
                            bestCandidates = [candidate];
                        } else if (score === bestScore) {
                            bestCandidates.push(candidate);
                        }
                    }
                    if (bestCandidates.length === 0) return null;
                    return bestCandidates[Math.floor(Math.random() * bestCandidates.length)];
                };

                const pickByCandidateNumbers = (candidateNumbers, forbiddenNumbers = new Set()) => {
                    if (!candidateNumbers || candidateNumbers.length === 0) return null;
                    const uniqueCandidates = [];
                    const seen = new Set();
                    for (const candidate of candidateNumbers) {
                        if (seen.has(candidate)) continue;
                        seen.add(candidate);
                        if (!hasPoolNumber(candidate)) continue;
                        uniqueCandidates.push(candidate);
                    }
                    if (uniqueCandidates.length === 0) return null;
                    const allowedCandidates = uniqueCandidates.filter(
                        candidate => !forbiddenNumbers.has(candidate)
                    );
                    if (allowedCandidates.length === 0) return null;
                    const source = allowedCandidates;
                    const picked = chooseCandidateByControl(source);
                    if (picked === null) return null;
                    return picked;
                };

                const pickAnyCard = (forbiddenNumbers = new Set()) => {
                    const candidates = [];
                    const allowedCandidates = [];
                    for (const poolItem of currentPool) {
                        const canUse = placedCounts[poolItem.number] < poolItem.count;
                        if (!canUse) continue;
                        candidates.push(poolItem.number);
                        if (!forbiddenNumbers.has(poolItem.number)) {
                            allowedCandidates.push(poolItem.number);
                        }
                    }
                    if (candidates.length === 0) return null;
                    const source = allowedCandidates.length > 0 ? allowedCandidates : candidates;
                    const picked = chooseCandidateByControl(source);
                    if (picked === null) return null;
                    return picked;
                };

                const adjacentSamePositionNumbers = getAdjacentSamePositionCandidateNumbers();
                const adjacentLineNumbers = Array.from(getAdjacentLineCandidateSet());
                const aroundNeighborNumbers = Array.from(getAroundNeighborCandidateSet());
                const forbiddenNumbers = new Set();
                const aroundNeighborNumberSet = new Set(aroundNeighborNumbers);

                const tryAdjacentLineSet = Math.random() < sameNum;
                if (!tryAdjacentLineSet) {
                    adjacentLineNumbers.forEach(value => forbiddenNumbers.add(value));
                }

                const trySamePosition = Math.random() < xianglinSame;
                if (trySamePosition) {
                    num = pickByCandidateNumbers(adjacentSamePositionNumbers, forbiddenNumbers);
                } else {
                    adjacentSamePositionNumbers.forEach(value => forbiddenNumbers.add(value));
                }

                if (num === null) {
                    if (tryAdjacentLineSet) {
                        num = pickByCandidateNumbers(adjacentLineNumbers, forbiddenNumbers);
                    }
                }

                if (num === null) {
                    const preferUsed = Math.random() < sameLie;
                    num = pickByGroupPreference(preferUsed, forbiddenNumbers);
                    if (num === null) {
                        num = pickByGroupPreference(!preferUsed, forbiddenNumbers);
                    }
                }

                if (num === null) {
                    num = pickAnyCard(forbiddenNumbers);
                }

                if (num === null) {
                    num = getNextCard();
                }

                if (num !== null) {
                    if (aroundNeighborNumberSet.has(num) && Math.random() >= distanceCtrl) {
                        const replaceForbiddenNumbers = new Set(forbiddenNumbers);
                        aroundNeighborNumberSet.forEach(value => replaceForbiddenNumbers.add(value));
                        const preferUsedForReplace = Math.random() < sameLie;
                        let replacement = pickByGroupPreference(
                            preferUsedForReplace,
                            replaceForbiddenNumbers
                        );
                        if (replacement === null) {
                            replacement = pickByGroupPreference(
                                !preferUsedForReplace,
                                replaceForbiddenNumbers
                            );
                        }
                        if (replacement === null && tryAdjacentLineSet) {
                            replacement = pickByCandidateNumbers(
                                adjacentLineNumbers,
                                replaceForbiddenNumbers
                            );
                        }
                        if (replacement === null) {
                            replacement = pickAnyCard(replaceForbiddenNumbers);
                        }
                        if (replacement !== null) {
                            num = replacement;
                        }
                    }

                    const reservedCard = getSpecificCard(num);
                    if (reservedCard === null) {
                        num = getNextCard();
                    }
                }

                if (num !== null) {
                    placedCounts[num] = (placedCounts[num] || 0) + 1;
                    filledCells[i][j] = num;
                }
            }

            return getBoardData();
        }

        function calculatePoolForGenerate(width, height) {
            const count8 = parseInt(document.getElementById('count8').value) || 0;
            const count6 = parseInt(document.getElementById('count6').value) || 0;

            const totalCells = width * height;
            const cardsFrom8 = count8 * 8;
            const cardsFrom6 = count6 * 6;
            const usedCards = cardsFrom8 + cardsFrom6;

            if (usedCards > totalCells) return [];

            const remainingCards = totalCells - usedCards;
            let count4 = Math.floor(remainingCards / 4);
            const remainder = remainingCards % 4;

            let count2 = 0;
            if (remainder >= 2) {
                count2 = 1;
            }

            currentPool = [];
            let num = 1;
            for (let i = 0; i < count8; i++) {
                currentPool.push({ number: num, count: 8 });
                num++;
            }
            for (let i = 0; i < count6; i++) {
                currentPool.push({ number: num, count: 6 });
                num++;
            }
            for (let i = 0; i < count4; i++) {
                currentPool.push({ number: num, count: 4 });
                num++;
            }
            for (let i = 0; i < count2; i++) {
                currentPool.push({ number: num, count: 2 });
                num++;
            }

            poolCards = [];
            currentPool.forEach(poolItem => {
                for (let i = 0; i < poolItem.count; i++) {
                    poolCards.push(poolItem.number);
                }
            });
            poolCards = shuffleArray(poolCards);
        }

        function calculateExportAverages(boardData, direction) {
            if (!boardData || boardData.length === 0 || boardData[0].length === 0) {
                return { adjacentBaselineAvg: 0, directionBothAvg: 0 };
            }

            const height = boardData.length;
            const width = boardData[0].length;
            const isRowDirection = isRowBaseDirection(direction);

            const lineCount = isRowDirection ? height : width;
            const lineSets = [];
            for (let lineIndex = 0; lineIndex < lineCount; lineIndex++) {
                const numberSet = new Set();
                if (isRowDirection) {
                    for (let j = 0; j < width; j++) {
                        const value = boardData[lineIndex]?.[j];
                        if (Number.isInteger(value) && value > 0) numberSet.add(value);
                    }
                } else {
                    for (let i = 0; i < height; i++) {
                        const value = boardData[i]?.[lineIndex];
                        if (Number.isInteger(value) && value > 0) numberSet.add(value);
                    }
                }
                lineSets.push(numberSet);
            }

            const countIntersection = (leftSet, rightSet) => {
                let overlapCount = 0;
                leftSet.forEach((value) => {
                    if (rightSet.has(value)) overlapCount++;
                });
                return overlapCount;
            };

            const adjacentOverlapStats = [];
            for (let lineIndex = 0; lineIndex < lineCount; lineIndex++) {
                let overlapTotal = 0;
                if (lineIndex > 0) {
                    overlapTotal += countIntersection(lineSets[lineIndex], lineSets[lineIndex - 1]);
                }
                if (lineIndex < lineCount - 1) {
                    overlapTotal += countIntersection(lineSets[lineIndex], lineSets[lineIndex + 1]);
                }
                adjacentOverlapStats.push(overlapTotal);
            }
            const adjacentOverlapSum = adjacentOverlapStats.reduce((sum, value) => sum + value, 0);
            const adjacentBaselineAvg = lineCount > 0 ? adjacentOverlapSum / lineCount : 0;

            const mergeSetMap = new Map();
            const lowerSetMap = new Map();
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const current = boardData[i]?.[j];
                    if (!Number.isInteger(current) || current <= 0) continue;
                    const localDirection = getLocalBaseDirectionByCell(direction, i, j, width, height);
                    if (localDirection === 0) continue;

                    const collectSideNumbersForBoard = (sideType) => {
                        const sideNumbers = new Set();
                        let stepI = 0;
                        let stepJ = 0;
                        if (localDirection === 1) {
                            stepI = sideType === 'top' ? 1 : -1;
                        } else if (localDirection === 2) {
                            stepI = sideType === 'top' ? -1 : 1;
                        } else if (localDirection === 3) {
                            stepJ = sideType === 'top' ? 1 : -1;
                        } else if (localDirection === 4) {
                            stepJ = sideType === 'top' ? -1 : 1;
                        }
                        let ni = i + stepI;
                        let nj = j + stepJ;
                        while (ni >= 0 && ni < height && nj >= 0 && nj < width) {
                            const value = boardData[ni]?.[nj];
                            if (Number.isInteger(value) && value > 0) sideNumbers.add(value);
                            ni += stepI;
                            nj += stepJ;
                        }
                        return sideNumbers;
                    };

                    const upperSet = collectSideNumbersForBoard('top');
                    const lowerSet = collectSideNumbersForBoard('bottom');

                    if (!mergeSetMap.has(current)) mergeSetMap.set(current, new Set());
                    if (!lowerSetMap.has(current)) lowerSetMap.set(current, new Set());

                    upperSet.forEach((value) => mergeSetMap.get(current).add(value));
                    lowerSet.forEach((value) => lowerSetMap.get(current).add(value));
                }
            }

            const numbers = Array.from(mergeSetMap.keys());
            let directionBothSum = 0;
            for (const numberValue of numbers) {
                const upperSet = mergeSetMap.get(numberValue) || new Set();
                const lowerSet = lowerSetMap.get(numberValue) || new Set();
                let bothCount = 0;
                upperSet.forEach((value) => {
                    if (lowerSet.has(value)) bothCount++;
                });
                directionBothSum += bothCount;
            }
            const directionBothAvg = numbers.length > 0 ? directionBothSum / numbers.length : 0;

            return { adjacentBaselineAvg, directionBothAvg };
        }

        function batchGenerate() {
            const count = parseInt(document.getElementById('batchCount').value) || 10;
            const direction = parseInt(document.querySelector('input[name="direction"]:checked')?.value || 0);
            const sameLie = getProbabilityValue('sameLie', 0.1);
            const sameNum = getProbabilityValue('sameNum', 0.1);
            const xianglinSame = getProbabilityValue('xianglinSame', 0.1);
            const directionBothCtrl = getProbabilityValue('directionBothCtrl', 0.5);
            const distanceCtrl = getProbabilityValue('distanceCtrl', 0.1);

            let result = '';
            const width = parseInt(document.getElementById('width').value) || 8;
            const height = parseInt(document.getElementById('height').value) || 14;

            for (let i = 0; i < count; i++) {
                const boardData = generateSingleLevel(
                    direction,
                    sameLie,
                    sameNum,
                    xianglinSame,
                    directionBothCtrl,
                    distanceCtrl
                );
                const boardStr = JSON.stringify(boardData);
                const exportAverages = calculateExportAverages(boardData, direction);
                result += `${i + 1}\t${boardStr}\t${direction}\t` +
                    `${exportAverages.adjacentBaselineAvg.toFixed(2)}\t` +
                    `${exportAverages.directionBothAvg.toFixed(2)}\n`;
            }

            const blob = new Blob([result], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `关卡批量生成_${width}x${height}_${count}个.txt`;
            a.click();
        }

        function init() {
            loadConfigGroupsFromStorage();
            const board = document.getElementById('board');
            if (board) {
                board.addEventListener('click', handleBoardCellClick);
                generateBoard();
            } else {
                window.addEventListener('DOMContentLoaded', () => {
                    loadConfigGroupsFromStorage();
                    const readyBoard = document.getElementById('board');
                    if (readyBoard) readyBoard.addEventListener('click', handleBoardCellClick);
                    generateBoard();
                    updatePlayModeButton();
                });
            }
            updatePlayModeButton();
            window.addEventListener('resize', scaleBoard);
        }

        function scaleBoard() {
            const wrapper = document.getElementById('boardWrapper');
            const container = document.querySelector('.board-container');
            if (!wrapper || !container) return;

            requestAnimationFrame(() => {
                const SCALE_SAFE_MARGIN = 2;
                const containerStyle = window.getComputedStyle(container);
                const horizontalPadding =
                    parseFloat(containerStyle.paddingLeft || '0') +
                    parseFloat(containerStyle.paddingRight || '0');
                const verticalPadding =
                    parseFloat(containerStyle.paddingTop || '0') +
                    parseFloat(containerStyle.paddingBottom || '0');
                const topTools = container.querySelector('.board-top-tools');
                const topToolsMarginBottom = topTools
                    ? parseFloat(window.getComputedStyle(topTools).marginBottom || '0')
                    : 0;
                const topToolsHeight = topTools ? topTools.offsetHeight + topToolsMarginBottom : 0;

                const containerWidth =
                    container.clientWidth - horizontalPadding - SCALE_SAFE_MARGIN;
                const containerHeight =
                    container.clientHeight -
                    verticalPadding -
                    topToolsHeight -
                    SCALE_SAFE_MARGIN;
                const boardWidth = wrapper.scrollWidth;
                const boardHeight = wrapper.scrollHeight;

                let scale = 1;
                if (boardWidth > containerWidth && containerWidth > 0) {
                    scale = Math.min(scale, containerWidth / boardWidth);
                }
                if (boardHeight > containerHeight && containerHeight > 0) {
                    scale = Math.min(scale, containerHeight / boardHeight);
                }

                wrapper.style.transform = `scale(${scale.toFixed(3)})`;
            });
        }

        init();
    </script>
</body>
</html>
